<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CareerPath | Ciclo de Estudos</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litepicker/dist/css/litepicker.css"/>

    <style>
        /* --- ESTILO BASE --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f8f9fa; color: #2c3e50; min-height: 100vh; }
        
        .app-container { display: flex; min-height: 100vh; }

        /* --- NAVEGAÇÃO LATERAL (NOVO LAYOUT) --- */
        .sidebar-nav {
            width: 260px;
            background-color: #0d253f;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            transition: width 0.3s ease;
            z-index: 1100; /* Acima do overlay do modal */
        }
        .sidebar-header {
            padding: 22px 25px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sidebar-header .logo-icon {
            width: 38px;
            height: 38px;
            fill: #ff6f61;
        }
        .sidebar-header h1 {
            font-size: 1.5em;
            font-weight: 600;
            color: #fff;
        }
        .sidebar-menu {
            flex-grow: 1;
            list-style: none;
            margin-top: 20px;
        }
        .sidebar-menu li {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 16px 25px;
            margin: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            color: #aeb8c2;
            font-weight: 500;
        }
        .sidebar-menu li .material-icons-outlined {
            font-size: 24px;
        }
        .sidebar-menu li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .sidebar-menu li.active {
            background-color: #ff6f61;
            color: #fff;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(255, 111, 97, 0.3);
        }
        .sidebar-footer {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .logout-button {
            display: flex;
            align-items: center;
            gap: 15px;
            background: none;
            border: none;
            color: #aeb8c2;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            width: 100%;
            text-align: left;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        .logout-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .main-content {
            margin-left: 260px; /* Largura da sidebar */
            width: calc(100% - 260px);
            padding: 30px;
            transition: margin-left 0.3s ease, width 0.3s ease;
        }

        .view { display: none; }
        .view.active { display: block; }
        
        .fullscreen-view { 
            text-align: center; 
            padding: 60px 20px; 
            background: white; 
            border-radius: 12px; 
            max-width: 550px; 
            margin: 60px auto; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); 
            border: 1px solid #e9ecef; 
        }
        .fullscreen-view h2 { margin-bottom: 15px; font-size: 1.8em; color: #003366; }
        .fullscreen-view p { margin-bottom: 30px; color: #6c757d; line-height: 1.6; }
        #login-button { display: inline-flex; align-items: center; gap: 15px; padding: 12px 28px; font-size: 16px; font-weight: 500; background: #4285F4; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        #login-button:hover { background-color: #357ae8; }
        #login-button svg { width: 20px; height: 20px; }

        /* --- ESTILOS DE CONTEÚDO PRINCIPAL --- */
        .content-wrapper, #cycle-selection-view { background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid #e9ecef; }
        .page-header { font-size: 2em; color: #003366; font-weight: 600; margin-bottom: 30px; display: flex; align-items: center; gap: 15px; }
        .page-header .material-icons-outlined { font-size: 1.2em; }

        /* --- BOTÕES E INPUTS --- */
        button { background-color: #0d253f; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: 500; font-family: 'Poppins', sans-serif; transition: transform 0.2s, box-shadow 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(13, 37, 63, 0.2); }
        button:disabled { background-color: #aeb8c2; opacity: 1; cursor: not-allowed; transform: none; box-shadow: none; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 12px; border: 1px solid #ced4da; border-radius: 8px; font-size: 16px; font-family: 'Poppins', sans-serif; transition: border-color 0.3s, box-shadow 0.3s; }
        input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: #ff6f61; box-shadow: 0 0 0 3px rgba(255, 111, 97, 0.2); }
        .remove-btn, button.secondary { background-color: #e9ecef; color: #495057; }
        .remove-btn:hover, button.secondary:hover { background-color: #dee2e6; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); }
        button.danger { background-color: #e74c3c; }
        button.danger:hover { box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3); }

        /* --- GRÁFICO E STATS --- */
        .chart-container { background-color: #fff; border: 1px solid #e9ecef; border-radius: 12px; padding: 20px; margin: 20px 0; display: flex; justify-content: center; position: relative; }
        #wheelChart text { fill: #6c757d; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background-color: #fff; border: 1px solid #e9ecef; color: #2c3e50; padding: 20px; border-radius: 12px; text-align: center; }
        .stat-number { font-size: 2em; font-weight: 600; color: #0d253f; margin-bottom: 5px; }
        .stat-label { font-size: 0.9em; color: #6c757d; }

        /* --- LISTA DE DISCIPLINAS --- */
        .discipline-list { margin: 20px 0; }
        .discipline-item { display: flex; align-items: center; gap: 15px; padding: 15px; margin: 10px 0; background: #fdfdff; border-radius: 10px; border: 1px solid #e9ecef; transition: all 0.3s; flex-wrap: wrap; border-left: 5px solid; }
        .discipline-item.completed { border-left-color: #28a745 !important; background-color: #f6fff8; }
        .discipline-name-group { flex: 1; display: flex; align-items: center; gap: 10px; font-weight: 500; min-width: 150px; }
        .edit-btn { background: none; border: none; color: #6c757d; cursor: pointer; padding: 4px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        .edit-btn:hover { background-color: #e9ecef; color: #0d253f; }
        .timer-btn { background-color: #28a745; font-size: 14px; padding: 10px 16px; }
        .timer-btn.stop { background-color: #ff6f61; }
        
        /* --- CALENDÁRIO --- */
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; }
        .calendar-nav-group { display: flex; align-items: center; gap: 10px; }
        .calendar-title { color: #0d253f; font-weight: 600; text-align: center; flex-grow: 1; }
        .view-toggles { display: flex; }
        .view-toggles button { font-size: 14px; padding: 6px 12px; border-radius: 6px; background-color: #e9ecef; color: #495057; border: 1px solid #dee2e6; }
        .view-toggles button.active { background-color: #0d253f; color: white; border-color: #0d253f; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day-header { text-align: center; font-weight: 600; color: #6c757d; font-size: 0.9em; padding-bottom: 10px; }
        .calendar-day { aspect-ratio: 1; border: 1px solid transparent; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; font-size: 14px; }
        .calendar-day:hover { background-color: #f0f3f5; }
        .calendar-day.today { border-color: #ff6f61; }
        .calendar-day.selected { background-color: #0d253f; color: white; }
        .calendar-day.has-studies { font-weight: 600; }        
        .calendar-nav { background-color: #0d253f; }
        .calendar-summary { text-align: center; font-size: 1.1em; font-weight: 500; color: #0d253f; background-color: #e9f0f5; padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .study-history { border-top: 1px solid #dee2e6; margin-top: 20px; padding-top: 20px; }
        .daily-total { font-size: 1.1em; font-weight: 600; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #e9ecef; }
        .study-history-item { padding: 8px; margin-top: 5px; background: #fdfdff; border-left: 3px solid #0d253f; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
        .history-delete-btn { background: #e74c3c; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px; line-height: 24px; text-align: center; padding: 0; }

        /* Novos estilos para os ícones de status no calendário */
        .calendar-day {
            position: relative; /* Necessário para posicionar o ícone */
            display: flex; /* Para alinhar o número do dia e o ícone */
            flex-direction: column; /* Coloca o número acima do ícone */
            justify-content: center;
            align-items: center;
            padding-top: 5px; /* Ajuste para dar espaço ao número */
        }

        .calendar-day .day-number {
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 2px; /* Espaço entre o número e o ícone */
        }
        .calendar-day.selected .day-number { /* Se o dia selecionado, número branco */
            color: white;
        }

        .calendar-day .status-icon {
            font-size: 18px; /* Tamanho dos ícones */
            position: absolute; /* Posição absoluta para o ícone */
            bottom: 5px; /* Alinha na parte inferior do dia */
            /* left: 50%; */ /* Remova ou ajuste esta propriedade para centralizar melhor */
            /* transform: translateX(-50%); */ /* Remova ou ajuste esta propriedade */
        }

        .calendar-day .status-success {
            color: #28a745; /* Verde para 'certo' */
        }

        .calendar-day .status-danger {
            color: #e74c3c; /* Vermelho para 'x' */
        }

        /* Ajustes para alinhar o conteúdo interno do calendar-day */
        .calendar-day {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* Garante que o ícone possa ser posicionado */
        }

        .calendar-day.has-studies .day-number {
             /* Estilo para o número do dia quando há estudos */
            font-weight: 600;
        }


        /* --- TELA DE RELATÓRIOS --- */
        .reports-filter-bar { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; margin-bottom: 30px; }
        .filter-group { display: flex; flex-direction: column; gap: 5px; }
        .filter-group label { font-size: 0.9em; font-weight: 500; color: #495057; }
        #report-date-input { width: 260px; text-align: center; cursor: pointer; }
        #report-cycle-filter { width: 220px; }

        .reports-kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .kpi-card { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; }
        .kpi-card .kpi-label { font-size: 1em; color: #6c757d; margin-bottom: 8px; }
        .kpi-card .kpi-value { font-size: 1.8em; font-weight: 600; color: #0d253f; }
        .reports-charts-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 30px; align-items: start; }
        .chart-wrapper { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; position: relative; height: 400px; }
        .chart-wrapper h3 { margin-bottom: 20px; font-weight: 500; color: #343a40; }
        .reports-breakdown { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; }
        .breakdown-header { display: grid; grid-template-columns: 1fr 100px 100px; padding: 0 15px 10px 15px; border-bottom: 2px solid #dee2e6; font-weight: 600; color: #6c757d; font-size: 0.9em; }
        .breakdown-header .d-right, .breakdown-row .d-right { text-align: right; }
        .breakdown-row { display: grid; grid-template-columns: 1fr 100px 100px; align-items: center; padding: 12px 15px; border-bottom: 1px solid #f1f3f5; }
        .breakdown-row.cycle-row { font-weight: 500; cursor: pointer; }
        .breakdown-row.cycle-row:hover { background-color: #f8f9fa; }
        .cycle-name-cell { display: flex; align-items: center; gap: 8px; }
        .cycle-color-dot { 
            width: 10px; 
            height: 10px; 
            border-radius: 50%; 
            display: inline-block; 
            margin-right: 8px; 
            vertical-align: middle; 
        }        .toggle-arrow { transition: transform 0.2s; }
        .cycle-row.expanded .toggle-arrow { transform: rotate(90deg); }
        .discipline-rows-wrapper { display: none; }
        .cycle-row.expanded + .discipline-rows-wrapper { display: block; }
        .discipline-row { padding-left: 40px; background-color: #fbfdff; }


        /* --- MODAIS E OUTROS --- */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1000; justify-content: center; align-items: center; padding: 20px; }
        .modal-content { background: white; padding: 30px 40px; border-radius: 12px; text-align: center; max-width: 500px; width: 100%; box-shadow: 0 5px 25px rgba(0,0,0,0.2); animation: modal-appear 0.3s ease-out; }
        @keyframes modal-appear { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .modal-content h3 { color: #0d253f; margin-bottom: 15px; font-size: 1.6em; }
        .modal-content p { margin-bottom: 30px; color: #6c757d; font-size: 1.1em; line-height: 1.6; }
        .modal-buttons { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .trophy-icon { width: 60px; height: 60px; margin: 0 auto 20px auto; fill: #ffc107; }
        .form-group-modal { margin-bottom: 15px; text-align: left; position: relative; /* Adicionado para posicionamento absoluto das sugestões */ }
        .form-group-modal label { display: block; margin-bottom: 5px; font-weight: 500; }
        #cycle-selection-view { text-align: center; padding: 40px 20px; max-width: 600px; margin: 40px auto; }
        .add-discipline-form { background: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .form-title { font-size: 1.2em; font-weight: 600; margin-bottom: 15px; color: #0d253f; }
        .input-row { display: flex; gap: 10px; align-items: flex-end; margin-bottom: 10px; }
        .input-row .input-group { flex-grow: 1; }
        .time-input-container { display: flex; gap: 10px; align-items: flex-end; }
        .time-input-group { display: flex; flex-direction: column; align-items: center; }
        .time-input-group label { font-size: 0.8em; color: #666; margin-bottom: 4px; }
        .time-input-group input { width: 70px; text-align: center; }
        .time-input-separator { font-size: 1.5em; color: #999; padding-bottom: 10px; }

        /* Estilos para seleção de cor do Ciclo */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        .color-box {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-box:hover {
            transform: translateY(-2px);
            border-color: #0d253f;
        }
        .color-box.selected {
            border-color: #0d253f;
            box-shadow: 0 0 0 3px rgba(13, 37, 63, 0.3);
            transform: scale(1.05);
        }
        .existing-cycles-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            padding: 15px;
            background-color: #f0f3f5;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .existing-cycle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: #e9ecef;
            font-size: 0.9em;
        }

        /* Estilos para a tela de Tags */
        #allTagsList {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
            align-items: flex-start; /* Alinha os itens ao topo */
        }
        .tag-item {
            display: inline-block;
            background-color: #e9ecef;
            color: #495057;
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap; /* Evita quebras de linha dentro da tag */
        }
        .tag-item:hover {
            background-color: #dee2e6;
            color: #0d253f;
        }
        .tag-item.active {
            background-color: #0d253f;
            color: white;
        }

        .tag-suggestions {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ced4da;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            width: 100%;
            z-index: 100;
            margin-top: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none; /* Escondido por padrão */
        }

        .tag-suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            text-align: left;
        }

        .tag-suggestion-item:hover,
        .tag-suggestion-item.active { 
            background-color: #f0f3f5;
        }


        .tag-results .breakdown-header {
            grid-template-columns: 2fr 100px; /* Ajuste para assunto/disciplina/Ciclo e duração */
        }
        .tag-results .tag-study-item {
            display: grid;
            grid-template-columns: 2fr 100px;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #f1f3f5;
            word-break: break-word; /* Permite quebras de palavras longas */
        }
        .tag-study-item .study-details {
            display: flex;
            flex-direction: column;
        }
        .tag-study-item .study-details .main-info {
            font-weight: 500;
            color: #2c3e50;
        }
        .tag-study-item .study-details .sub-info {
            font-size: 0.85em;
            color: #6c757d;
        }

        /* Estilos para Modais Específicos */
        #addTimeToDayModal .modal-content {
            max-width: 400px; /* Reduz a largura máxima do modal */
            padding: 20px;   /* Reduz o padding geral do modal */
            overflow-y: auto; /* Permite scroll se o conteúdo for muito alto */
            max-height: 90vh; /* Limita a altura máxima para não estourar a tela */
        }
        .study-history-item .edit-btn.secondary {
            padding: 4px 8px; /* Reduz o padding */
            font-size: 12px; /* Reduz o tamanho da fonte */
            border-radius: 4px; /* Apenas uma leve borda */
            min-width: 50px; /* Garante que não fique minúsculo */
        }
        /* Ajustes para os grupos de input de tempo dentro DOS MODAIS GERALMENTE */
        .modal-content .time-input-container {
            flex-wrap: wrap; 
            justify-content: center;
            gap: 3px; /* Reduz ainda mais o espaço entre os campos de tempo */
            margin-bottom: 15px; /* Adiciona um espaço inferior */
        }

        .modal-content .time-input-group {
            flex: 1 1 55px; /* Permite flexibilidade, com base de 55px */
            max-width: 70px; /* Limita a largura máxima para cada HH/MM/SS */
            min-width: 50px; /* Garante um tamanho mínimo menor */
            align-items: center; /* Centraliza os itens dentro do grupo */
        }

        .modal-content .time-input-group label {
            font-size: 0.7em; /* Reduz um pouco mais a fonte dos labels HH/MM/SS */
            margin-bottom: 2px;
            white-space: nowrap; /* Impede que o label quebre linha */
        }

        .modal-content .time-input-group input {
            width: 100%; 
            padding: 5px; /* Reduz o padding para economizar espaço */
            font-size: 12px; /* Diminui a fonte do texto dentro do input */
            height: 30px; /* Altura fixa ligeiramente menor para inputs de tempo */
        }

        .modal-content .time-input-separator {
            font-size: 0.9em; /* Diminui o tamanho do separador ':' */
            padding-bottom: 0;
            margin-top: 10px; 
        }

        /* Ajuste para garantir que os selects (Ciclo/Disciplina) não sejam muito largos */
        .form-group-modal select {
            width: 100%;
            padding: 8px 12px; /* Reduz o padding dos selects */
            font-size: 14px; /* Reduz a fonte dos selects */
        }

        /* Ajuste para os textareas e inputs de texto */
        .form-group-modal textarea,
        .form-group-modal input[type="text"] {
            padding: 8px 10px; /* Reduz o padding */
            font-size: 14px; /* Reduz a fonte */
        }

        /* Regra específica para o modal AddTimeToDay, para garantir a centralização dos botões */
        #addTimeToDayModal .modal-buttons {
            margin-top: 20px; /* Garante espaço acima dos botões */
            gap: 10px; /* Reduz o espaço entre os botões */
        }
        #addTimeToDayModal .modal-buttons button {
            padding: 10px 15px; /* Reduz o padding dos botões */
            font-size: 14px; /* Reduz a fonte dos botões */
        }

        /* Media query para telas médias (já existia, só ajustar os valores se achar necessário) */
        @media (max-width: 1440px) {
            #addTimeToDayModal .modal-content {
                max-width: 380px; /* Pode tentar reduzir para 380px ou 360px */
                padding: 18px 20px; 
            }
        }

        /* Media query para telas menores (smartphones, para ter certeza) */
        @media (max-width: 768px) { /* Use 768px para atingir tablets e smartphones em landscape */
            #addTimeToDayModal .modal-content {
                max-width: 95%; /* Ocupa a maior parte da largura */
                padding: 15px; /* Padding mínimo */
            }
            .modal-content .time-input-group {
                flex: 1 1 60px; /* Mais flexibilidade */
                min-width: 55px;
            }
            .modal-content .time-input-separator {
                display: flex; /* Mantém o ':' mas pode ser removido em 480px se ainda apertar */
            }
        }

        @media (max-width: 480px) {
            #addTimeToDayModal .modal-content {
                max-width: 98%; 
                padding: 10px; /* Padding ainda menor */
            }
            .modal-content .time-input-group {
                flex: 1 1 auto; /* Permite que ocupe o espaço que precisar, but with min-width */
                min-width: 45px; /* Min-width for each HH/MM/SS field */
                max-width: none; /* No max-width here, to shrink */
            }
            .modal-content .time-input-separator {
                display: none; /* Hides the ":" on very small screens to save space */
            }
            #addTimeToDayModal .modal-buttons {
                flex-direction: column; /* Stack buttons on very small screens */
            }
        }

        /* Media query para telas ainda menores (celulares, por exemplo) */
        @media (max-width: 600px) {
            #addTimeToDayModal .modal-content {
                max-width: 95%; 
                margin: 20px auto; 
                padding: 20px; 
            }

            .modal-content .time-input-container {
                flex-wrap: wrap; 
                justify-content: center;
            }

            .modal-content .time-input-group {
                width: calc(33% - 10px); 
                min-width: 80px; 
            }
             .modal-content .time-input-group input {
                width: 100%;
                max-width: none;
            }
            .modal-content .time-input-separator {
                display: none; 
            }
        }

        @media (max-width: 992px) {
            .sidebar-nav { width: 70px; }
            .sidebar-nav .sidebar-header h1, .sidebar-nav .menu-text, .sidebar-nav .logout-text { display: none; }
            .sidebar-nav .sidebar-header { justify-content: center; padding: 20px 0;}
            .main-content { margin-left: 70px; width: calc(100% - 70px); }
            .sidebar-menu li { justify-content: center; }
            .sidebar-footer .logout-button { justify-content: center; }
        }

        @media (max-width: 768px) {
            .reports-charts-grid { grid-template-columns: 1fr; }
            .breakdown-header, .breakdown-row { grid-template-columns: 1fr 80px 70px; font-size: 0.9em; }
            .main-content { padding: 15px; }
        }

        @media (max-width: 600px) {
            .sidebar-nav { display: none; } 
            .main-content { margin-left: 0; width: 100%; } 
            .calendar-header { flex-direction: column; gap: 15px; }
            body { padding: 5px; }
            .main-content { padding: 10px; }
            .content-wrapper, #cycle-selection-view { padding: 15px; }
            .page-header { font-size: 1.5em; }
            .add-discipline-form .input-row { flex-wrap: wrap; gap: 15px; }
            .add-discipline-form .input-group { width: 100%; min-width: 100%; }
            .add-discipline-form .time-input-container { flex-grow: 1; }
            .add-discipline-form button { flex-grow: 1; }
            .stats { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
        }
    </style>
</head>
<body>

    <div id="app-wrapper">
        
        <aside class="sidebar-nav" style="display: none;">
            <div class="sidebar-header">
                <svg class="logo-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256 256-114.6 256-256S399.4 0 256 0zm0 464C141.1 464 48 370.9 48 256S141.1 48 256 48s208 93.1 208 208-93.1 208-208 208zm-62.5-133.3l105.3-43.9 43.9-105.3-105.3 43.9-43.9 105.3z"/></svg>
                <h1 class="menu-text">CareerPath</h1>
            </div>
            <ul class="sidebar-menu">
                <li onclick="switchView('current')" data-view="current">
                    <span class="material-icons-outlined">timer</span>
                    <span class="menu-text">Timer</span>
                </li>
                <li onclick="switchView('reports')" data-view="reports">
                    <span class="material-icons-outlined">bar_chart</span>
                    <span class="menu-text">Relatórios</span>
                </li>
                <li onclick="switchView('calendar')" data-view="calendar">
                    <span class="material-icons-outlined">calendar_today</span>
                    <span class="menu-text">Calendário</span>
                </li>
                <li onclick="switchView('tags')" data-view="tags">
                    <span class="material-icons-outlined">label</span>
                    <span class="menu-text">Tags</span>
                </li>
            </ul>
            <div class="sidebar-footer">
                <button class="logout-button" onclick="signOutUser()">
                    <span class="material-icons-outlined">exit_to_app</span>
                    <span class="logout-text">Sair</span>
                </button>
            </div>
        </aside>

        <main class="main-content">
            <div id="loading-view" class="view active fullscreen-view">
                <h2>Carregando...</h2>
                <p>Verificando sua conta CareerPath.</p>
            </div>

            <div id="login-view" class="view fullscreen-view">
                <h2>Bem-vindo ao seu Controle de Estudos</h2>
                <p>Faça login com sua conta Google para salvar e sincronizar seus históricos de estudo na plataforma CareerPath.</p>
                <button id="login-button" onclick="signInWithGoogle()">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="24px" height="24px"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24s8.955,20,20,20s20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"/><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"/><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.223,0-9.651-3.358-11.303-8H6.306C9.656,39.663,16.318,44,24,44z"/><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C39.901,35.636,44,30.138,44,24C44,22.659,43.862,21.35,43.611,20.083z"/></svg>
                    <span>Entrar com Google</span>
                </button>
            </div>

            <div id="cycle-selection-view" class="view content-wrapper">
                <h2>Selecione ou Crie um Ciclo</h2>
                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label for="existingCycleSelector" style="display: block; margin-bottom: 8px; font-weight: 500;">Escolha um Ciclo existente</label>
                    <select id="existingCycleSelector"></select>
                </div>
                <button onclick="loadSelectedCycle()">Carregar Ciclo</button>
                <div style="margin: 25px 0; font-weight: bold; color: #999;">OU</div>
                
                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label for="newCycleNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Crie um novo Ciclo</label>
                    <input type="text" id="newCycleNameInput" placeholder="Ex: Trilha Front-End...">
                </div>

                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cores de Ciclos existentes:</label>
                    <div id="existingCyclesDisplay" class="existing-cycles-display">
                        </div>
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Escolha uma cor para o novo Ciclo:</label>
                    <div id="cycleColorPalette" class="color-palette">
                        </div>
                </div>
                <button onclick="createNewCycle()">Criar e Iniciar</button>
                <button class="danger" onclick="signOutUser()" style="margin-top: 30px;">Sair</button>
            </div>

            <div id="current-view" class="view">
                <header class="page-header">
                    <span class="material-icons-outlined">track_changes</span>
                    <span id="cycleTitleText"></span>
                </header>
                <div class="content-wrapper">
                    <div id="main-content">
                        <div class="stats">
                            <div class="stat-card"><div class="stat-number" id="cycleCompletions">0</div><div class="stat-label">Vezes Concluído</div></div>
                            <div class="stat-card"><div class="stat-number" id="totalDisciplines">0</div><div class="stat-label">Disciplinas</div></div>
                            <div class="stat-card"><div class="stat-number" id="totalHours">0h</div><div class="stat-label">Horas Hoje</div></div>
                        </div>
                        
                        <div class="add-discipline-form">
                            <div class="form-title">Adicionar Nova Disciplina</div>
                            <div class="input-row">
                                <div class="input-group"><input type="text" id="disciplineInput" placeholder="Nome da disciplina..."></div>
                                <div class="time-input-container">
                                    <div class="time-input-group">
                                        <label for="hoursInput">Horas</label>
                                        <input type="number" id="hoursInput" min="0" placeholder="HH" value="1">
                                    </div>
                                    <span class="time-input-separator">:</span>
                                    <div class="time-input-group">
                                        <label for="minutesInput">Minutos</label>
                                        <input type="number" id="minutesInput" min="0" max="59" step="5" placeholder="MM" value="0">
                                    </div>
                                </div>
                                <button onclick="addDiscipline()">Adicionar</button>
                            </div>
                        </div>

                        <div class="chart-container" id="chartContainer"><svg id="wheelChart" width="400" height="400" viewBox="0 0 400 400"></svg></div>
                        
                        <h3 style="margin-top: 30px; margin-bottom: 15px; color: #0d253f;">Disciplinas Ativas</h3>
                        <div class="discipline-list" id="disciplinesList"></div>
                        
                        <h3 style="margin-top: 30px; margin-bottom: 15px; color: #0d253f;">Disciplinas Arquivadas</h3>
                        <div class="discipline-list" id="archivedDisciplinesList"></div>

                        <div id="mainControls" style="display:flex; flex-wrap: wrap; gap:10px; justify-content:center; margin-top:30px;">
                            <button class="secondary" onclick="returnToCycleSelection()">Trocar de Ciclo</button>
                            <button class="secondary" onclick="manuallyEndCycle()">Encerrar Ciclo</button>
                            <button class="danger" onclick="deleteCurrentCycle()">Apagar Ciclo Atual</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="calendar-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">calendar_today</span> Calendário de Estudos</header>
                <div class="content-wrapper">
                    <div class="calendar-header">
                        <div class="calendar-nav-group">
                            <button class="calendar-nav" onclick="navigateCalendar(-1)">❮</button>
                            <h2 id="calendarTitle" class="calendar-title"></h2>
                            <button class="calendar-nav" onclick="navigateCalendar(1)">❯</button>
                        </div>
                        <div class="view-toggles">
                            <button id="view-toggle-month" class="active" onclick="setCalendarView('month')">Mês</button>
                            <button id="view-toggle-week" onclick="setCalendarView('week')">Semana</button>
                        </div>
                    </div>
                    <div id="calendar-summary" class="calendar-summary"></div>
                    <div class="calendar-grid">
                        <div class="calendar-day-header">Dom</div><div class="calendar-day-header">Seg</div><div class="calendar-day-header">Ter</div><div class="calendar-day-header">Qua</div><div class="calendar-day-header">Qui</div><div class="calendar-day-header">Sex</div><div class="calendar-day-header">Sáb</div>
                    </div>
                    <div class="calendar-grid" id="calendarGrid"></div>
                    <div id="selectedDateInfo" class="study-history" style="display: none;"></div>
                </div>
            </div>

            <div id="reports-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">bar_chart</span> Relatórios</header>
                <div class="content-wrapper">
                    <div class="reports-filter-bar">
                        <div class="filter-group">
                            <label for="report-date-input">Período</label>
                            <input type="text" id="report-date-input" readonly>
                        </div>
                        <div class="filter-group">
                            <label for="report-cycle-filter">Filtrar por Ciclo</label>
                            <select id="report-cycle-filter" onchange="renderReportsView()"></select>
                        </div>
                    </div>

                    <div class="reports-kpi-grid">
                        <div class="kpi-card">
                            <div class="kpi-label">Duração Total</div>
                            <div class="kpi-value" id="report-total-hours">00:00:00</div>
                        </div>
                        <div class="kpi-card">
                            <div class="kpi-label">Média Diária</div>
                            <div class="kpi-value" id="report-daily-average">00:00:00</div>
                        </div>
                    </div>

                    <div class="reports-charts-grid">
                        <div class="chart-wrapper">
                            <h3>Duração por Dia</h3>
                            <canvas id="durationBarChart"></canvas>
                        </div>
                        <div class="chart-wrapper">
                            <h3>Distribuição por Ciclo</h3>
                            <canvas id="distributionDonutChart"></canvas>
                        </div>
                    </div>

                    <div class="reports-breakdown">
                        <div class="breakdown-header">
                            <span>Ciclo / DISCIPLINA</span>
                            <span class="d-right">DURAÇÃO</span>
                            <span class="d-right">%</span>
                        </div>
                        <div id="breakdown-table-body"></div>
                    </div>
                </div>
            </div>
            <div id="tags-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">label</span> Buscar por Tags</header>
                <div class="content-wrapper">
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label for="tagSearchInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Pesquisar Tags (Ex: #python)</label>
                        <input type="text" id="tagSearchInput" placeholder="Digite uma tag ou parte dela..." onkeyup="filterTagsAndStudies()">
                        <div id="allTagsList" style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px;">
                            </div>
                    </div>
                    
                    <div class="tag-results" id="tagSearchResults">
                        <h4 style="margin-bottom: 15px; color: #0d253f;">Resultados da Busca</h4>
                        <div class="breakdown-header">
                            <span>Assunto / Disciplina / Ciclo</span>
                            <span class="d-right">DURAÇÃO</span>
                        </div>
                        <div id="tagResultsBody">
                            <p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado para exibir. Use a busca acima ou clique em uma tag.</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <div id="completionModal" class="modal-overlay"> <div class="modal-content"> <h3>Ciclo Concluído!</h3> <p>Parabéns! Você atingiu a meta de todas as disciplinas. O que deseja fazer agora?</p> <div class="modal-buttons"> <button class="secondary" onclick="handleContinueCycle()">Continuar Neste Ciclo</button> <button onclick="handleStartNewCycle()">Iniciar Novo Ciclo</button> </div> </div> </div>
    <div id="celebrationModal" class="modal-overlay"> <div class="modal-content"> <svg class="trophy-icon" viewBox="0 0 24 24"><path d="M20.2,4H22L19,2H5L2,4h1.8C4.4,4.8,5,5.9,5,7c0,1.5-1.2,2.7-2.7,2.9C2.1,10,2,10.1,2,10.3V12h1v9H2v1h20v-1h-1v-9h1v-1.7 c0-0.2-0.1-0.3-0.3-0.4C21.2,9.7,20,8.5,20,7C20,5.9,20.6,4.8,21.2,4H20.2z M4,12h2.1c0.5-0.7,1.2-1.3,2-1.7V12H4z M15.9,10.3 c0.8,0.4,1.5,1,2,1.7H20V12h-4.1V10.3z M12,6c1.1,0,2,0.9,2,2s-0.9,2-2,2s-2-0.9-2-2S10.9,6,12,6z"/></svg> <h3>Missão Cumprida!</h3> <p>Você é incrível! O Ciclo foi concluído com sucesso e contabilizado. Pronto para o próximo desafio?</p> <div class="modal-buttons"> <button onclick="hideCelebrationModal()">Fechar</button> </div> </div> </div>
    <div id="alertModal" class="modal-overlay"> <div class="modal-content"> <h3 id="alertModalTitle">Atenção</h3> <p id="alertModalMessage"></p> <div class="modal-buttons"> <button onclick="hideAlertModal()">OK</button> </div> </div> </div>
    <div id="confirmModal" class="modal-overlay"> <div class="modal-content"> <h3 id="confirmModalTitle">Confirmar Ação</h3> <p id="confirmModalMessage"></p> <div class="modal-buttons"> <button class="secondary" onclick="hideConfirmModal()">Cancelar</button> <button class="danger" onclick="handleConfirmAction()">Confirmar</button> </div> </div> </div>
    <div id="editDisciplineModal" class="modal-overlay"> 
        <div class="modal-content"> 
            <h3>Editar Disciplina</h3> 
            <input type="hidden" id="editDisciplineId"> 
            <div class="form-group-modal"> 
                <label for="editDisciplineName">Nome da Disciplina</label> 
                <input type="text" id="editDisciplineName"> 
            </div> 
            <div class="form-group-modal"> 
                <label>Meta de Tempo</label> 
                <div class="time-input-container" style="justify-content: center;"> 
                    <div class="time-input-group"> 
                        <label for="editHoursInput">Horas</label> 
                        <input type="number" id="editHoursInput" min="0" placeholder="HH"> 
                    </div> 
                    <span class="time-input-separator">:</span> 
                    <div class="time-input-group"> 
                        <label for="editMinutesInput">Minutos</label> 
                        <input type="number" id="editMinutesInput" min="0" max="59" step="5" placeholder="MM"> 
                    </div> 
                </div> 
            </div> 
            <div class="form-group-modal">
                <label>Cor da Disciplina</label>
                <div id="editDisciplineColorPalette" class="color-palette"></div>
            </div>
            <div class="modal-buttons"> 
                <button class="secondary" onclick="hideEditModal()">Cancelar</button> 
                <button onclick="saveDisciplineChanges()">Salvar Alterações</button> 
            </div> 
        </div> 
    </div>

<div id="addTimeModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Tempo Manualmente</h3>
            <input type="hidden" id="addTimeDisciplineId">
            <div class="form-group-modal">
                <label>Tempo a Adicionar</label>
                <div class="time-input-container" style="justify-content: center;">
                    <div class="time-input-group">
                        <label for="addTimeHoursInput">Horas</label>
                        <input type="number" id="addTimeHoursInput" min="0" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeMinutesInput">Minutos</label>
                        <input type="number" id="addTimeMinutesInput" min="0" max="59" step="5" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeSecondsInput">Segundos</label>
                        <input type="number" id="addTimeSecondsInput" min="0" max="59" step="1" value="0">
                    </div>
                </div>
            </div>
            <div class="form-group-modal">
                <label for="addTimeSubjectInput">Assunto (Opcional)</label>
                <input type="text" id="addTimeSubjectInput" placeholder="Ex: Métodos em JS" list="subjectRecommendations">
            </div>

            <div class="form-group-modal">
                <label for="addTimeTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="addTimeTagsInput" placeholder="Ex: #javascript, #frontend">
                <div id="addTimeTagSuggestions" class="tag-suggestions"></div> </div>

            <div class="form-group-modal">
                <label for="addTimeStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="addTimeStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="hideAddTimeModal()">Cancelar</button>
                <button onclick="saveAddedTime()">Adicionar</button>
            </div>
        </div>
    </div>


<div id="addTimeToDayModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Tempo ao Dia</h3>
            <p>Adicione tempo de estudo para a data selecionada: <strong id="addTimeToDayModalDate"></strong></p>
            <input type="hidden" id="addTimeToDaySelectedDate">

            <div class="form-group-modal">
                <label for="addTimeToDayCycleSelect">Ciclo de Estudo</label>
                <select id="addTimeToDayCycleSelect" onchange="populateAddTimeToDayDisciplines()"></select>
            </div>

            <div class="form-group-modal">
                <label for="addTimeToDayDisciplineSelect">Disciplina</label>
                <select id="addTimeToDayDisciplineSelect"></select>
            </div>
            
            <div class="form-group-modal">
                <label>Tempo Estudado</label>
                <div class="time-input-container" style="justify-content: center;">
                    <div class="time-input-group">
                        <label for="addTimeToDayHoursInput">Horas</label>
                        <input type="number" id="addTimeToDayHoursInput" min="0" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeToDayMinutesInput">Minutos</label>
                        <input type="number" id="addTimeToDayMinutesInput" min="0" max="59" step="5" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeToDaySecondsInput">Segundos</label>
                        <input type="number" id="addTimeToDaySecondsInput" min="0" max="59" step="1" value="0">
                    </div>
                </div>
            </div>
            <div class="form-group-modal">
                <label for="addTimeToDaySubjectInput">Assunto (Opcional)</label>
                <input type="text" id="addTimeToDaySubjectInput" placeholder="Ex: Estruturas de Dados" list="subjectRecommendations">
            </div>

            <div class="form-group-modal">
                <label for="addTimeToDayTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="addTimeToDayTagsInput" placeholder="Ex: #algoritmos, #computacao">
                <div id="addTimeToDayTagSuggestions" class="tag-suggestions"></div> </div>

            <div class="form-group-modal">
                <label for="addTimeToDayStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="addTimeToDayStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="hideAddTimeToDayModal()">Cancelar</button>
                <button onclick="saveAddTimeToDayEntry()">Adicionar Tempo</button>
            </div>
        </div>
    </div>

    <div id="editStudyRecordModal" class="modal-overlay">
    <div class="modal-content">
        <h3>Editar Registro de Estudo</h3>
        <input type="hidden" id="editRecordStudyId"> <input type="hidden" id="editRecordDateStr">
        <input type="hidden" id="editRecordDisciplineId">
        <input type="hidden" id="editRecordCycleId"> <div class="form-group-modal">
            <label for="editRecordDisciplineName">Disciplina</label>
            <input type="text" id="editRecordDisciplineName" readonly style="background-color: #f8f9fa;">
        </div>

        <div class="form-group-modal">
            <label>Tempo Estudado</label>
            <div class="time-input-container" style="justify-content: center;">
                <div class="time-input-group">
                    <label for="editRecordHoursInput">Horas</label>
                    <input type="number" id="editRecordHoursInput" min="0" value="0">
                </div>
                <span class="time-input-separator">:</span>
                <div class="time-input-group">
                    <label for="editRecordMinutesInput">Minutos</label>
                    <input type="number" id="editRecordMinutesInput" min="0" max="59" step="5" value="0">
                </div>
                <span class="time-input-separator">:</span>
                <div class="time-input-group">
                    <label for="editRecordSecondsInput">Segundos</label>
                    <input type="number" id="editRecordSecondsInput" min="0" max="59" step="1" value="0">
                </div>
            </div>
        </div>
        <div class="form-group-modal">
            <label for="editRecordSubjectInput">Assunto (Opcional)</label>
            <input type="text" id="editRecordSubjectInput" placeholder="Ex: Métodos em JS" list="subjectRecommendations">
        </div>

        <div class="form-group-modal">
            <label for="editRecordTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
            <input type="text" id="editRecordTagsInput" placeholder="Ex: #javascript, #frontend">
            <div id="editRecordTagSuggestions" class="tag-suggestions"></div> </div>

        <div class="form-group-modal">
            <label for="editRecordStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
            <textarea id="editRecordStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
        </div>
        <div class="modal-buttons">
            <button class="secondary" onclick="hideEditStudyRecordModal()">Cancelar</button>
            <button onclick="saveEditedStudyRecord()">Salvar Alterações</button>
        </div>
    </div>
</div>

    <div class="tooltip" id="tooltip" style="position: fixed; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px; pointer-events: none; display: none; z-index: 1000; white-space: nowrap; transition: opacity 0.2s;"></div>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/litepicker.js"></script>

<div id="startTimerModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Iniciar Estudo: <span id="startTimerDisciplineName"></span></h3>
            <input type="hidden" id="startTimerDisciplineId">

            <div class="form-group-modal">
                <label for="startTimerSubjectInput">Assunto (Opcional)</label>
                <input type="text" id="startTimerSubjectInput" placeholder="Ex: Funções em Python" list="subjectRecommendations">
                <datalist id="subjectRecommendations"></datalist>
            </div>

            <div class="form-group-modal">
                <label for="startTimerTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="startTimerTagsInput" placeholder="Ex: #python, #logica">
                <div id="startTimerTagSuggestions" class="tag-suggestions"></div> </div>

           
            <div class="modal-buttons">
                <button class="secondary" onclick="hideStartTimerModal()">Cancelar</button>
                <button onclick="confirmStartTimer()">Iniciar Timer</button>
            </div>
        </div>
    </div>

    <div id="stopTimerModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Pausar Estudo: <span id="stopTimerDisciplineName"></span></h3>
            <input type="hidden" id="stopTimerDisciplineId">
            <input type="hidden" id="stopTimerStudyRecordIndex">
            <input type="hidden" id="stopTimerStudyDate">
            <input type="hidden" id="stopTimerStudyCycleId">

            <div class="form-group-modal">
                <label for="stopTimerStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="stopTimerStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            
            <div class="modal-buttons">
                <button class="secondary" onclick="cancelStopTimer()">Cancelar</button>
                <button onclick="confirmStopTimer()">Pausar</button>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDU50I5YKjP-pH8NfCuc59N5_U0rzbeac4", 
            authDomain: "ciclo-de-estudo-elias.firebaseapp.com", 
            projectId: "ciclo-de-estudo-elias", 
            storageBucket: "ciclo-de-estudo-elias.appspot.com",
            messagingSenderId: "1065929930079",
            appId: "1:1065929930079:web:28eaffabc8daeb7ff732ea",
            measurementId: "G-KX8EJZD2CQ"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const provider = new firebase.auth.GoogleAuthProvider();

        
        // Cor reservada para relatórios (não pode ser usada para disciplinas)
        const REPORT_RESERVED_COLOR = '#0D253F';

        // Paleta de cores para os Ciclos de estudo (vibrantes e distintas)
        const CYCLE_COLOR_PALETTE = [
            '#E6194B',  // Vermelho Vivo
            '#F58231',  // Laranja Forte
            '#FFE119',  // Amarelo Intenso
            '#BFEF45',  // Verde Limão
            '#3CB44B',  // Verde Floresta
            '#42D4F4',  // Verde Água
            '#4363D8',  // Azul Céu
            '#000075',  // Azul Marinho
            '#911EB4',  // Roxo Púrpura
            '#F032E6',  // Magenta
            '#FABED4',  // Rosa Choque
            '#A52A2A',  // Marrom Terra
            '#FFD8B1',  // Bege Claro
            '#808080',  // Cinza Carvão
            '#469990',  // Azul Petróleo
            '#46F0F0',  // Turquesa Vibrante
            '#0066FF',  // Azul Royal
            '#FF6700',  // Laranja Neon
            '#00FF87',  // Verde Neon
            '#FFD700',  // Amarelo Ouro
            '#FF1493',  // Rosa Neon
            '#8A2BE2'   // Violeta Elétrico
        ];

        // Função para remover emojis de uma string
        function removeEmojis(str) {
            // Expressão regular para remover a maioria dos emojis Unicode.
            // Pode precisar de ajustes dependendo da gama de emojis que você encontrar.
            return str.replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu, '');
        }
        
        // Gerador de cores aleatórias que evita a cor reservada (para disciplinas)
        class ColorGenerator {
            constructor() {
                this.usedColors = new Set();
                this.minDistance = 100; // Distância mínima entre cores no espaço RGB
            }

            // Converte HSL para RGB
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }

            // Calcula distância entre duas cores no espaço RGB
            colorDistance(rgb1, rgb2) {
                return Math.sqrt(
                    Math.pow(rgb1[0] - rgb2[0], 2) +
                    Math.pow(rgb1[1] - rgb2[1], 2) +
                    Math.pow(rgb1[2] - rgb2[2], 2)
                );
            }

            // Converte RGB para hex
            rgbToHex(r, g, b) {
                return `#${r.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}`;
            }

            // Gera cor vibrante usando HSL
            generateVibrantColor(reservedColor = null) {
                let attempts = 0;
                const maxAttempts = 100;

                while (attempts < maxAttempts) {
                    // HSL para cores mais vibrantes
                    const hue = Math.floor(Math.random() * 360); // 0-359
                    const saturation = Math.floor(Math.random() * 30) + 70; // 70-100% (alta saturação)
                    const lightness = Math.floor(Math.random() * 30) + 45; // 45-75% (nem muito escuro, nem muito claro)

                    const [r, g, b] = this.hslToRgb(hue, saturation, lightness);
                    const color = this.rgbToHex(r, g, b);

                    // Verifica se não é a cor reservada
                    if (reservedColor && color.toLowerCase() === reservedColor.toLowerCase()) {
                        attempts++;
                        continue;
                    }

                    // Verifica distância das cores já usadas
                    let isDistinct = true;
                    for (const usedColor of this.usedColors) {
                        const usedRgb = [
                            parseInt(usedColor.slice(1, 3), 16),
                            parseInt(usedColor.slice(3, 5), 16),
                            parseInt(usedColor.slice(5, 7), 16)
                        ];
                        
                        if (this.colorDistance([r, g, b], usedRgb) < this.minDistance) {
                            isDistinct = false;
                            break;
                        }
                    }

                    if (isDistinct) {
                        this.usedColors.add(color);
                        return color;
                    }

                    attempts++;
                }

                // Fallback: se não conseguir gerar cor distinta, gera uma aleatória
                const hue = Math.floor(Math.random() * 360);
                const [r, g, b] = this.hslToRgb(hue, 80, 60);
                const fallbackColor = this.rgbToHex(r, g, b);
                this.usedColors.add(fallbackColor);
                return fallbackColor;
            }

            // Limpa histórico de cores usadas
            reset() {
                this.usedColors.clear();
            }

            // Gera palette de cores distintas
            generatePalette(count, reservedColor = null) {
                this.reset();
                const palette = [];
                
                for (let i = 0; i < count; i++) {
                    palette.push(this.generateVibrantColor(reservedColor));
                }
                
                return palette;
            }
        }

        const disciplineColorGenerator = new ColorGenerator(); // Renomeado para clareza

        // Função para obter cor de uma disciplina (gera uma nova se não existir)
        function getDisciplineColor(disciplineId, cycleId) {
            if (!appData.cycles[cycleId]) return disciplineColorGenerator.generateVibrantColor(REPORT_RESERVED_COLOR);
            
            const cycle = appData.cycles[cycleId];
            if (!cycle.disciplineColors) cycle.disciplineColors = {};
            
            if (!cycle.disciplineColors[disciplineId]) {
                cycle.disciplineColors[disciplineId] = disciplineColorGenerator.generateVibrantColor(REPORT_RESERVED_COLOR);
                saveData(); // Salva a nova cor
            }
            
            return cycle.disciplineColors[disciplineId];
        }
        
        let appData = { cycles: {}, activeCycleId: null, allSubjects: [], allTags: [] };  
        let activeCycle = null;
        let allSubjects = new Set();
        let allTags = new Set();
        let timers = {};
        let currentCalendarDate = new Date();
        let selectedDate = null;
        let unsubscribe;
        let confirmCallback = null;
        let calendarViewMode = 'month';
        let selectedNewCycleColor = null; // Variável para armazenar a cor selecionada para o novo Ciclo
        let selectedEditDisciplineColor = null; // Variável para a cor selecionada no modal de edição
        let recordToStop = null; // Armazena a referência ao registro de estudo que será parado
        let durationBarChart = null;
        let distributionDonutChart = null;
        let reportStartDate, reportEndDate;
        let reportDatePicker = null;
        let reportsInitialized = false;

        let activeTagFilter = ''; // Para armazenar a tag ativa que está sendo filtrada

        class TagAutocomplete {
            constructor(inputId, suggestionsContainerId) {
                this.input = document.getElementById(inputId);
                this.suggestionsContainer = document.getElementById(suggestionsContainerId);
                this.availableTags = [];

                if (this.input) {
                    this.input.addEventListener('input', this.handleInput.bind(this));
                    this.input.addEventListener('keydown', this.handleKeyDown.bind(this));
                    this.input.addEventListener('focus', this.handleFocus.bind(this));
                    this.input.addEventListener('blur', this.handleBlur.bind(this));
                }
            }

            setAvailableTags(tags) {
                // Armazena as tags originais para seleção e suas versões normalizadas para busca
                this.availableTags = tags.map(tag => ({
                    original: tag,
                    normalized: removeEmojis(tag).toLowerCase()
                }));
                this.filterSuggestions(this.getCurrentTagTerm());
            }

            getCurrentTagTerm() {
                const inputValue = this.input.value;
                const lastCommaIndex = inputValue.lastIndexOf(',');
                const lastSpaceIndex = inputValue.lastIndexOf(' ');
                
                let lastSeparatorIndex = -1;
                if (lastCommaIndex > lastSpaceIndex) {
                    lastSeparatorIndex = lastCommaIndex;
                } else if (lastSpaceIndex !== -1) {
                    lastSeparatorIndex = lastSpaceIndex;
                }

                if (lastSeparatorIndex === -1) {
                    return removeEmojis(inputValue).trim().toLowerCase(); // Normaliza o termo atual
                } else {
                    return removeEmojis(inputValue.substring(lastSeparatorIndex + 1)).trim().toLowerCase(); // Normaliza o termo atual
                }
            }

            handleInput() {
                const currentTerm = this.getCurrentTagTerm();
                this.filterSuggestions(currentTerm);
            }

            filterSuggestions(term) {
                this.suggestionsContainer.innerHTML = '';
                this.suggestionsContainer.style.display = 'none';

                if (term.length === 0 && (this.input.value.endsWith(',') || this.input.value.endsWith(' '))) {
                    // Não mostra sugestões imediatamente após uma vírgula ou espaço se não houver novo termo
                    return;
                }

                // Filtra as tags com base na versão normalizada
                const filtered = this.availableTags.filter(tagObj => tagObj.normalized.startsWith(term));

                if (filtered.length > 0) {
                    filtered.forEach(tagObj => {
                        const suggestionItem = document.createElement('div');
                        suggestionItem.textContent = tagObj.original; // Exibe a tag original com emoji
                        suggestionItem.classList.add('tag-suggestion-item');
                        // Ao clicar, seleciona a tag original
                        suggestionItem.addEventListener('mousedown', (e) => {
                            e.preventDefault(); // Evita que o blur feche as sugestões antes do click
                            this.selectSuggestion(tagObj.original); 
                        });
                        this.suggestionsContainer.appendChild(suggestionItem);
                    });
                    this.suggestionsContainer.style.display = 'block';
                }
            }

            selectSuggestion(tag) {
                const inputValue = this.input.value;
                const lastCommaIndex = inputValue.lastIndexOf(',');
                const lastSpaceIndex = inputValue.lastIndexOf(' ');
                
                let lastSeparatorIndex = -1;
                if (lastCommaIndex > lastSpaceIndex) {
                    lastSeparatorIndex = lastCommaIndex;
                } else if (lastSpaceIndex !== -1) {
                    lastSeparatorIndex = lastSpaceIndex;
                }

                let newValue;
                // Ao selecionar, NÃO adiciona a vírgula automaticamente
                if (lastSeparatorIndex === -1) {
                    newValue = tag; // Substitui o que está digitado pela tag selecionada
                } else {
                    const prefix = inputValue.substring(0, lastSeparatorIndex + 1);
                    newValue = prefix + tag; // Adiciona a tag após o último delimitador
                }
                this.input.value = newValue;
                this.input.focus();
                this.suggestionsContainer.style.display = 'none';
            }

            handleKeyDown(e) {
                const items = this.suggestionsContainer.querySelectorAll('.tag-suggestion-item');
                if (items.length === 0) return;

                let currentIndex = -1;
                items.forEach((item, index) => {
                    if (item.classList.contains('active')) {
                        currentIndex = index;
                    }
                });

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentIndex = (currentIndex + 1) % items.length;
                    this.setActiveSuggestion(items, currentIndex);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentIndex = (currentIndex - 1 + items.length) % items.length;
                    this.setActiveSuggestion(items, currentIndex);
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentIndex !== -1) {
                        this.selectSuggestion(items[currentIndex].textContent);
                    }
                }
            }

            setActiveSuggestion(items, index) {
                items.forEach((item, i) => {
                    if (i === index) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            }

            handleFocus() {
                this.filterSuggestions(this.getCurrentTagTerm());
            }

            handleBlur() {
                // Delay hiding to allow mousedown on suggestions to fire
                setTimeout(() => {
                    this.suggestionsContainer.style.display = 'none';
                }, 100);
            }
        }

        let addTimeTagsAutocomplete;
        let addTimeToDayTagsAutocomplete;
        let editRecordTagsAutocomplete;
        let startTimerTagsAutocomplete;


        function renderAllTags(filterTerm = '') { // Adicionado parâmetro filterTerm
            const allTagsListEl = document.getElementById('allTagsList');
            allTagsListEl.innerHTML = ''; // Limpa a lista existente
            
            const normalizedFilterTerm = removeEmojis(filterTerm).toLowerCase();

            if (allTags.size === 0) {
                allTagsListEl.innerHTML = '<p style="color: #6c757d; font-size: 0.9em; margin: 0;">Nenhuma tag registrada ainda.</p>';
                return;
            }

            // Converte o Set para Array, ordena alfabeticamente pela versão normalizada
            Array.from(allTags).sort((a, b) => removeEmojis(a).localeCompare(removeEmojis(b))).forEach(tag => {
                const normalizedTag = removeEmojis(tag).toLowerCase();
                // Filtra as tags exibidas no allTagsList com base no filterTerm
                if (filterTerm && !normalizedTag.includes(normalizedFilterTerm)) {
                    return; // Ignora tags que não correspondem ao filtro
                }

                const tagItem = document.createElement('span');
                tagItem.className = 'tag-item';
                // Compara a tag normalizada para definir o estado ativo
                if (normalizedTag === removeEmojis(activeTagFilter).toLowerCase()) {
                    tagItem.classList.add('active');
                }
                tagItem.textContent = tag;
                tagItem.onclick = () => selectTagForFilter(tag);
                allTagsListEl.appendChild(tagItem);
            });
        }

        function selectTagForFilter(tag) {
            // Normaliza a tag selecionada para comparação
            const normalizedTag = removeEmojis(tag).toLowerCase();
            const normalizedActiveTagFilter = removeEmojis(activeTagFilter).toLowerCase();

            if (normalizedActiveTagFilter === normalizedTag) {
                activeTagFilter = ''; // Desseleciona a tag se for clicada novamente
            } else {
                activeTagFilter = tag; // Seleciona a tag original (com emoji)
            }
            document.getElementById('tagSearchInput').value = ''; // Limpa a busca textual
            renderAllTags(); // Re-renderiza para atualizar o estado ativo
            filterTagsAndStudies(); // Filtra os estudos com a nova tag ativa
        }

        function filterTagsAndStudies() {
            const searchInput = removeEmojis(document.getElementById('tagSearchInput').value).trim().toLowerCase(); // Normaliza o input de busca
            const tagResultsBody = document.getElementById('tagResultsBody'); // Corrigido para 'tagResultsBody'
            tagResultsBody.innerHTML = '';
            
            renderAllTags(searchInput); // Atualiza a lista de tags exibidas com base no input de busca

            const allStudyRecords = []; 

            Object.values(appData.cycles || {}).forEach(cycle => {
                if (cycle.studyHistory) {
                    Object.entries(cycle.studyHistory).forEach(([dateStr, disciplineRecordsMap]) => {
                        Object.entries(disciplineRecordsMap).forEach(([discId, recordsArray]) => {
                            if (Array.isArray(recordsArray)) {
                                const discipline = cycle.disciplines.find(d => String(d.id) === discId);
                                if (discipline) {
                                    recordsArray.forEach(record => {
                                        allStudyRecords.push({
                                            cycleId: cycle.id,
                                            cycleColor: cycle.color,
                                            disciplineName: discipline.name,
                                            disciplineId: discipline.id,
                                            date: dateStr,
                                            time: record.time || 0,
                                            subject: record.subject || '',
                                            tags: record.tags || [],
                                            timestamp: record.timestamp || null 
                                        });
                                    });
                                }
                            }
                        });
                    });
                }
            });

            // Pré-filtra todos os estudos pelo searchInput (se houver)
            const preFilteredStudies = allStudyRecords.filter(study => {
                if (!searchInput) return true; // Se não houver searchInput, todos os estudos são considerados

                const searchLower = searchInput; 
                const subjectLower = study.subject ? removeEmojis(study.subject).toLowerCase() : ''; 
                const disciplineLower = study.disciplineName ? removeEmojis(study.disciplineName).toLowerCase() : ''; 
                const cycleLower = study.cycleId ? removeEmojis(study.cycleId).toLowerCase() : ''; 
                const tagsLower = study.tags.map(t => removeEmojis(t).toLowerCase()).join(' '); 

                return subjectLower.includes(searchLower) || 
                       disciplineLower.includes(searchLower) || 
                       cycleLower.includes(searchLower) ||
                       tagsLower.includes(searchLower);
            });

            const filteredAndGrouped = {}; 
            const activeTagFilterNormalized = removeEmojis(activeTagFilter).toLowerCase();

            // Popula filteredAndGrouped com base nos filtros
            preFilteredStudies.forEach(study => {
                let studyHasMatchingTag = false;
                if (study.tags && study.tags.length > 0) {
                    study.tags.forEach(tag => {
                        const tagLowerNormalized = removeEmojis(tag).toLowerCase(); 
                        if (!activeTagFilter || tagLowerNormalized === activeTagFilterNormalized) {
                            if (!filteredAndGrouped[tag]) { 
                                filteredAndGrouped[tag] = [];
                            }
                            filteredAndGrouped[tag].push(study);
                            studyHasMatchingTag = true;
                        }
                    });
                }

                // Se não houver tags ou se as tags do estudo não corresponderem ao filtro de tags,
                // e houver searchInput mas não activeTagFilter, adiciona a 'Sem Tags'.
                // Ou se não houver nenhum filtro, adiciona tudo.
                if (!studyHasMatchingTag && 
                    ((!activeTagFilter && searchInput && preFilteredStudies.includes(study)) || 
                     (!activeTagFilter && !searchInput))
                ) {
                    if (!filteredAndGrouped['Sem Tags']) {
                        filteredAndGrouped['Sem Tags'] = [];
                    }
                    filteredAndGrouped['Sem Tags'].push(study);
                }
            });

            const sortedTags = Array.from(Object.keys(filteredAndGrouped)).sort((a,b) => removeEmojis(a).localeCompare(removeEmojis(b)));
            
            if (sortedTags.length === 0) {
                if (searchInput || activeTagFilter) {
                     tagResultsBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado encontrado para o filtro atual.</p>';
                } else {
                     tagResultsBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado para exibir. Use a busca acima ou clique em uma tag.</p>';
                }
                return; 
            } 
            
            sortedTags.forEach(tag => {
                const tagStudies = filteredAndGrouped[tag].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()); 
                let totalTimeForTag = tagStudies.reduce((sum, s) => sum + s.time, 0);

                const tagHeader = document.createElement('div');
                tagHeader.className = 'breakdown-row cycle-row';
                tagHeader.innerHTML = `
                    <div class="cycle-name-cell" onclick="toggleCycleDetails(this.parentNode)">
                        <span class="material-icons-outlined toggle-arrow">chevron_right</span>
                        <span>${tag}</span> 
                    </div>
                    <span class="d-right">${formatTime(totalTimeForTag)}</span>
                    <span></span> `;
                tagResultsBody.appendChild(tagHeader);

                const studiesWrapper = document.createElement('div');
                    studiesWrapper.className = 'discipline-rows-wrapper'; 
                    tagStudies.forEach(study => {
                        const recordTime = study.timestamp ? formatTimestampToHHMM(study.timestamp) : '';
                        studiesWrapper.innerHTML += `
                            <div class="tag-study-item">
                                <div class="study-details">
                                    <span class="main-info">
                                        <span class="cycle-color-dot" style="background-color:${study.cycleColor};"></span> ${study.subject || 'Sem Assunto'}
                                    </span>
                                    <span class="sub-info">${study.disciplineName} (${study.cycleId}) - ${new Date(study.date + 'T12:00:00').toLocaleDateString('pt-BR')} ${recordTime ? `às ${recordTime}` : ''}</span>
                                </div>
                                <span class="d-right">${formatTime(study.time)}</span>
                            </div>
                        `;
                    });
                    tagResultsBody.appendChild(studiesWrapper);
            });
        }

     
       function getLocalDateString(date = new Date()) {
            // Cria um novo objeto Date que representa o início do dia NA HORA LOCAL
            const localDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            // Formata esta data local para YYYY-MM-DD
            if (typeof dateFns !== 'undefined' && dateFns.format) {
                return dateFns.format(localDate, 'yyyy-MM-dd');
            } else {
                // Fallback mais robusto para garantir a data local, se dateFns não estiver disponível
                const year = localDate.getFullYear();
                const month = (localDate.getMonth() + 1).toString().padStart(2, '0');
                const day = localDate.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
        }

        // Nova função para formatar timestamp para HH:MM
        function formatTimestampToHHMM(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        async function handleAuth() {
            console.log("handleAuth: Iniciando verificação de autenticação...");
            auth.onAuthStateChanged(async (user) => {
                const sidebar = document.querySelector('.sidebar-nav');
                const mainContent = document.querySelector('.main-content');
                if (user) {
                    console.log("handleAuth: Usuário autenticado. UID:", user.uid);
                    sidebar.style.display = 'flex';
                    mainContent.style.marginLeft = getComputedStyle(sidebar).width;
                    await loadUserData(user.uid);
                } else {
                    console.log("handleAuth: Usuário não autenticado.");
                    if (unsubscribe) {
                        unsubscribe();
                        unsubscribe = null; 
                    }
                    activeCycle = null;
                    appData = { cycles: {}, activeCycleId: null, allSubjects: [], allTags: [] }; // Reset allSubjects and allTags
                    Object.values(timers).forEach(clearInterval);
                    timers = {};
                    reportsInitialized = false;
                    
                    sidebar.style.display = 'none';
                    mainContent.style.marginLeft = '0';
                    switchView('login');
                }
            });
            try { 
                await auth.getRedirectResult(); 
            } catch (error) { 
                console.error("handleAuth: Erro no redirecionamento de autenticação:", error); 
            }
        }

        function signInWithGoogle() { 
            auth.signInWithPopup(provider).catch((error) => {
                console.error("signInWithGoogle: Erro no login:", error);
                showAlertModal('Erro de Login', `Não foi possível fazer login com o Google. Erro: ${error.message}`);
            }); 
        }

        function signOutUser() { 
            auth.signOut().catch((error) => {
                console.error("signOutUser: Erro ao deslogar:", error);
                showAlertModal('Erro ao Sair', `Não foi possível sair. Erro: ${error.message}`);
            });
            reportsInitialized = false; // Reinicia o estado dos relatórios ao deslogar
        }

        async function loadUserData(userId) {
            if (unsubscribe) unsubscribe();
            const userDocRef = db.collection('users').doc(userId);
            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    // Inicializa com as novas propriedades se o documento não existir
                    await userDocRef.set({ cycles: {}, activeCycleId: null, allSubjects: [], allTags: [] }); 
                }
                unsubscribe = userDocRef.onSnapshot(snapshot => {
                    if (!snapshot.exists) return;
                    appData = snapshot.data();
                    
                    // Garante que cada sub-registro de estudo tenha um ID único.
                    // Isso é importante para edição e exclusão de registros individuais no calendário.
                    // Percorre todos os ciclos, dias e disciplinas para adicionar um ID se ele não existir.
                    Object.values(appData.cycles || {}).forEach(cycle => {
                        if (cycle.disciplines) { // Garante que isArchived seja inicializado
                            cycle.disciplines.forEach(discipline => {
                                if (typeof discipline.isArchived === 'undefined') {
                                    discipline.isArchived = false; // Define como não arquivada por padrão
                                }
                            });
                        }
                        if (cycle.studyHistory) {
                            Object.values(cycle.studyHistory).forEach(dailyRecordsMap => {
                                Object.entries(dailyRecordsMap).forEach(([discId, recordsArray]) => {
                                    if (Array.isArray(recordsArray)) {
                                        dailyRecordsMap[discId] = recordsArray.map(record => {
                                            if (!record.id) {
                                                // Cria um ID único, combinando timestamp e um número aleatório para evitar colisões
                                                return { ...record, id: Date.now() + Math.random() };
                                            }
                                            return record;
                                        });
                                    }
                                });
                            });
                        }
                    });

                    // Carrega assuntos e tags do Firestore
                    allSubjects = new Set(appData.allSubjects || []);
                    allTags = new Set(appData.allTags || []);
                    
                    // Inicializa os autocompletes após carregar os dados
                    if (!addTimeTagsAutocomplete) {
                        addTimeTagsAutocomplete = new TagAutocomplete('addTimeTagsInput', 'addTimeTagSuggestions');
                    }
                    if (!addTimeToDayTagsAutocomplete) {
                        addTimeToDayTagsAutocomplete = new TagAutocomplete('addTimeToDayTagsInput', 'addTimeToDayTagSuggestions');
                    }
                    if (!editRecordTagsAutocomplete) {
                        editRecordTagsAutocomplete = new TagAutocomplete('editRecordTagsInput', 'editRecordTagSuggestions');
                    }
                     if (!startTimerTagsAutocomplete) {
                        startTimerTagsAutocomplete = new TagAutocomplete('startTimerTagsInput', 'startTimerTagSuggestions');
                    }
                    // Atualiza as tags disponíveis em todos os autocompletes
                    const currentAllTags = Array.from(allTags);
                    addTimeTagsAutocomplete.setAvailableTags(currentAllTags);
                    addTimeToDayTagsAutocomplete.setAvailableTags(currentAllTags);
                    editRecordTagsAutocomplete.setAvailableTags(currentAllTags);
                    startTimerTagsAutocomplete.setAvailableTags(currentAllTags);


                    Object.values(timers).forEach(clearInterval);
                    timers = {};
                    if (appData.activeCycleId && appData.cycles[appData.activeCycleId]) {
                        activeCycle = appData.cycles[appData.activeCycleId];
                        switchView('current');
                        updateDisplay(); // Este é o único ponto de atualização da UI após onSnapshot
                    } else {
                        activeCycle = null; 
                        populateCycleSelector();
                        renderCycleColorPalette();
                        renderExistingCyclesDisplay();
                        switchView('cycle-selection');
                    }
                }, error => {
                    console.error("loadUserData: Erro no listener do Firestore:", error);
                    showAlertModal('Erro de Conexão', 'Não foi possível carregar seus dados.');
                });
            } catch (error) {
                 console.error("loadUserData: Erro ao carregar dados do usuário:", error);
                 showAlertModal('Erro Crítico', 'Não foi possível carregar seus dados.');
            }
        }

       function saveData() {
            if (auth.currentUser) {
                const userId = auth.currentUser.uid;
                const dataToSave = JSON.parse(JSON.stringify(appData));
                if(dataToSave.activeCycleId && dataToSave.cycles[dataToSave.activeCycleId]) {
                    dataToSave.cycles[dataToSave.activeCycleId].disciplines.forEach(d => d.isRunning = false);
                }
                
                // Recalcula allSubjects e allTags ANTES de salvar
                recalculateAllSubjectsAndTags();
                
                // Salva os sets de assuntos e tags como arrays
                dataToSave.allSubjects = Array.from(allSubjects);
                dataToSave.allTags = Array.from(allTags);

                db.collection('users').doc(userId).set(dataToSave).catch(error => {
                    console.error("saveData: Erro ao salvar dados:", error);
                    showAlertModal('Erro ao Salvar', 'Não foi possível salvar suas alterações.');
                });
                // Não chame updateDisplay() ou renderCalendar() aqui diretamente.
                // O listener onSnapshot em loadUserData() cuidará disso quando o dado for atualizado no Firestore.
            }
        }

        // Modificado para notificar os autocompletes
        function updateAllSubjectsAndTags(subject, tags) {
            if (subject) {
                allSubjects.add(subject);
            }
            tags.forEach(tag => allTags.add(tag));
            populateSubjectRecommendations();
            
            // Notifica os autocompletes sobre as novas tags
            const currentAllTags = Array.from(allTags);
            if (addTimeTagsAutocomplete) addTimeTagsAutocomplete.setAvailableTags(currentAllTags);
            if (addTimeToDayTagsAutocomplete) addTimeToDayTagsAutocomplete.setAvailableTags(currentAllTags);
            if (editRecordTagsAutocomplete) editRecordTagsAutocomplete.setAvailableTags(currentAllTags);
            if (startTimerTagsAutocomplete) startTimerTagsAutocomplete.setAvailableTags(currentAllTags);
        }

        function recalculateAllSubjectsAndTags() {
            allSubjects.clear(); // Limpa os sets existentes
            allTags.clear();

            Object.values(appData.cycles || {}).forEach(cycle => {
                if (cycle.studyHistory) {
                    Object.values(cycle.studyHistory).forEach(dailyRecordsMap => {
                        Object.values(dailyRecordsMap).forEach(disciplineRecordsArray => {
                            if (Array.isArray(disciplineRecordsArray)) {
                                disciplineRecordsArray.forEach(record => {
                                    if (record.subject) {
                                        allSubjects.add(record.subject);
                                    }
                                    if (record.tags && Array.isArray(record.tags)) {
                                        record.tags.forEach(tag => allTags.add(tag));
                                    }
                                });
                            }
                        });
                    });
                }
            });
        }

        function populateSubjectRecommendations() {
            const datalist = document.getElementById('subjectRecommendations');
            if (!datalist) return;
            datalist.innerHTML = '';
            // Converte o Set para Array e ordena alfabeticamente
            Array.from(allSubjects).sort().forEach(subject => {
                const option = document.createElement('option');
                option.value = subject;
                datalist.appendChild(option);
            });
        }
        
        function returnToCycleSelection() {
            Object.keys(timers).forEach(clearInterval); // Clear all active timers
            if (appData.activeCycleId !== null) {
                appData.activeCycleId = null;
                saveData(); // Will trigger onSnapshot and update UI
            } else {
                populateCycleSelector();
                renderCycleColorPalette();
                renderExistingCyclesDisplay();
                switchView('cycle-selection');
            }
        }

        function populateCycleSelector() {
            const selector = document.getElementById('existingCycleSelector');
            selector.innerHTML = '<option value="">-- Selecione um Ciclo --</option>';
            const cycleIds = Object.keys(appData.cycles || {});
            if (cycleIds.length > 0) {
                cycleIds.forEach(id => selector.innerHTML += `<option value="${id}">${id}</option>`);
                selector.disabled = false;
                selector.parentElement.nextElementSibling.disabled = false;
            } else {
                selector.innerHTML = '<option value="">Nenhum Ciclo criado</option>';
                selector.disabled = true;
                selector.parentElement.nextElementSibling.disabled = true;
            }
        }

        function renderCycleColorPalette() {
            const paletteContainer = document.getElementById('cycleColorPalette');
            paletteContainer.innerHTML = '';
            CYCLE_COLOR_PALETTE.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                colorBox.setAttribute('data-color', color);
                colorBox.onclick = () => selectCycleColor(color);
                paletteContainer.appendChild(colorBox);
            });

            // Seleciona a primeira cor por padrão se nenhuma estiver selecionada
            if (!selectedNewCycleColor) {
                selectCycleColor(CYCLE_COLOR_PALETTE[0]);
            } else {
                // Se já houver uma cor selecionada, garante que ela apareça como selecionada
                const selectedBox = paletteContainer.querySelector(`[data-color="${selectedNewCycleColor}"]`);
                if (selectedBox) {
                    selectedBox.classList.add('selected');
                }
            }
        }

        // Nova função para renderizar a paleta de cores para edição de disciplina
        function renderDisciplineColorPalette(selectedColor) {
            const paletteContainer = document.getElementById('editDisciplineColorPalette');
            paletteContainer.innerHTML = '';
            CYCLE_COLOR_PALETTE.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                colorBox.setAttribute('data-color', color);
                colorBox.onclick = () => selectEditDisciplineColor(color);
                paletteContainer.appendChild(colorBox);
            });

            // Seleciona a cor atual da disciplina ou a primeira cor por padrão
            selectedEditDisciplineColor = selectedColor || CYCLE_COLOR_PALETTE[0];
            const selectedBox = paletteContainer.querySelector(`[data-color="${selectedEditDisciplineColor}"]`);
            if (selectedBox) {
                selectedBox.classList.add('selected');
            }
        }

        // Nova função para selecionar uma cor no modal de edição de disciplina
        function selectEditDisciplineColor(color) {
            selectedEditDisciplineColor = color;
            document.querySelectorAll('#editDisciplineColorPalette .color-box').forEach(box => {
                box.classList.remove('selected');
            });
            const selectedBox = document.querySelector(`#editDisciplineColorPalette [data-color="${color}"]`);
            if (selectedBox) {
                selectedBox.classList.add('selected');
            }
        }


        function selectCycleColor(color) {
            selectedNewCycleColor = color;
            document.querySelectorAll('.color-box').forEach(box => {
                box.classList.remove('selected');
            });
            const selectedBox = document.querySelector(`.color-box[data-color="${color}"]`);
            if (selectedBox) {
                selectedBox.classList.add('selected');
            }
        }

        function renderExistingCyclesDisplay() {
            const existingCyclesDisplay = document.getElementById('existingCyclesDisplay');
            existingCyclesDisplay.innerHTML = '';
            const cycleIds = Object.keys(appData.cycles || {});
            if (cycleIds.length > 0) {
                cycleIds.forEach(id => {
                    const cycle = appData.cycles[id];
                    if (cycle && cycle.color) {
                        const cycleItem = document.createElement('div');
                        cycleItem.className = 'existing-cycle-item';
                        cycleItem.innerHTML = `<span class="cycle-color-dot" style="background-color:${cycle.color};"></span><span>${id}</span>`;
                        existingCyclesDisplay.appendChild(cycleItem);
                    }
                });
            } else {
                existingCyclesDisplay.innerHTML = '<p style="margin: 0; color: #6c757d;">Nenhum Ciclo criado ainda.</p>';
            }
        }

        function loadSelectedCycle() {
            const selectedId = document.getElementById('existingCycleSelector').value;
            if (selectedId && appData.cycles[selectedId]) {
                appData.activeCycleId = selectedId;
                saveData(); // Will trigger onSnapshot and update UI
            } else {
                showAlertModal('Seleção Inválida', 'Por favor, selecione um Ciclo válido para carregar.');
            }
        }
        
        function createNewCycle() {
            const newName = document.getElementById('newCycleNameInput').value.trim();
            if (!newName) { 
                showAlertModal('Nome Inválido', 'Por favor, dê um nome ao novo Ciclo.'); 
                return; 
            }
            if (appData.cycles[newName]) { 
                showAlertModal('Nome Duplicado', 'Já existe um Ciclo com esse nome.'); 
                return; 
            }
            if (!selectedNewCycleColor) {
                showAlertModal('Cor Inválida', 'Por favor, selecione uma cor para o novo Ciclo.');
                return;
            }

            appData.cycles[newName] = { 
                id: newName, 
                disciplines: [], 
                completions: 0, 
                studyHistory: {},
                disciplineColors: {}, // Campo para armazenar cores das disciplinas (ainda aleatórias)
                color: selectedNewCycleColor // Armazena a cor escolhida para o Ciclo
            };
            appData.activeCycleId = newName;
            saveData(); // Will trigger onSnapshot and update UI
        }

        function deleteCurrentCycle() {
            if (!activeCycle) return;
            showConfirmModal(
                'Apagar Ciclo',
                `Tem certeza que deseja apagar o Ciclo '${activeCycle.id}'? Esta ação é irreversível.`,
                () => {
                    Object.keys(timers).forEach(clearInterval); // Stop all active timers
                    // Manually clear all relevant data for the cycle to prevent lingering issues
                    // This data will eventually be removed by Firestore rules, but local cleanup is good.
                    if (activeCycle.studyHistory) {
                        for (const dateStr in activeCycle.studyHistory) {
                            delete activeCycle.studyHistory[dateStr];
                        }
                    }
                    activeCycle.disciplines = [];
                    activeCycle.disciplineColors = {};

                    delete appData.cycles[activeCycle.id];
                    appData.activeCycleId = null; // Ensure no active cycle ID after deletion
                    activeCycle = null; // Clear active cycle object
                    saveData(); // Save changes. This will trigger onSnapshot and refresh UI.
                    // No direct calls to renderCalendar(), renderReportsView(), updateDisplay(), switchView() here.
                    // The onSnapshot listener in loadUserData() handles the final UI state.
                }
            );
        }

        function addDiscipline() {
            if (!activeCycle) {
                showAlertModal('Nenhum Ciclo Ativo', 'Crie um Ciclo antes de adicionar disciplinas.');
                return;
            }
            const nameInput = document.getElementById('disciplineInput');
            const hours = parseInt(document.getElementById('hoursInput').value, 10) || 0;
            const minutes = parseInt(document.getElementById('minutesInput').value, 10) || 0;
            const disciplineName = nameInput.value.trim();
            const targetSeconds = (hours * 3600) + (minutes * 60);

            if (!disciplineName || targetSeconds <= 0) { 
                showAlertModal('Dados Inválidos', 'Insira um nome e uma meta de tempo válida.');
                return; 
            }
            if (activeCycle.disciplines.some(d => d.name.toLowerCase() === disciplineName.toLowerCase())) {
                showAlertModal('Nome Duplicado', 'Já existe uma disciplina com esse nome.');
                return; 
            }

            const newDisciplineId = Date.now();
            activeCycle.disciplines.push({ 
                id: newDisciplineId, 
                name: disciplineName, 
                currentSeconds: 0, 
                targetSeconds: targetSeconds, 
                isRunning: false,
                isArchived: false // Nova propriedade: não arquivada por padrão
            });
            
            // Gera uma cor aleatória para a nova disciplina
            getDisciplineColor(newDisciplineId, activeCycle.id);
            
            nameInput.value = '';
            document.getElementById('hoursInput').value = '1';
            document.getElementById('minutesInput').value = '0';
            saveData(); // Will trigger onSnapshot and update UI
        }
        
        function removeDiscipline(id) {
            if (!activeCycle) return;
            showConfirmModal(
                'Remover Disciplina',
                'Tem certeza que deseja remover esta disciplina? Todo o histórico de estudo associado a ela será excluído permanentemente.',
                () => {
                    if (timers[id]) stopTimer(id, false);

                    // 1. Remover a disciplina da lista de disciplinas do ciclo
                    activeCycle.disciplines = activeCycle.disciplines.filter(d => d.id !== id);
                    
                    // 2. Remover a cor da disciplina
                    if (activeCycle.disciplineColors && activeCycle.disciplineColors[id]) {
                        delete activeCycle.disciplineColors[id];
                    }

                    // 3. Remover todos os registros de estudo associados a esta disciplina do histórico
                    const newStudyHistory = {};
                    for (const dateStr in activeCycle.studyHistory) {
                        const dailyRecords = activeCycle.studyHistory[dateStr];
                        const newDailyRecords = {};
                        let dayHasRemainingStudies = false;

                        for (const disciplineIdStr in dailyRecords) {
                            // Se a disciplinaIdStr do registro não é a que está sendo removida
                            if (String(disciplineIdStr) !== String(id)) { 
                                newDailyRecords[disciplineIdStr] = dailyRecords[disciplineIdStr];
                                if (newDailyRecords[disciplineIdStr].length > 0) {
                                    dayHasRemainingStudies = true;
                                }
                            }
                        }
                        // Só adiciona a entrada do dia ao newStudyHistory se houver estudos restantes
                        if (dayHasRemainingStudies) {
                            newStudyHistory[dateStr] = newDailyRecords;
                        }
                    }
                    activeCycle.studyHistory = newStudyHistory; // Atribui o histórico limpo

                    saveData(); // Will trigger onSnapshot and update UI
                    // No direct calls to renderCalendar(), renderReportsView(), updateDisplay() here.
                    // The onSnapshot listener in loadUserData() handles the final UI state.
                }
            );
        }
        
        function manuallyEndCycle() {
            if (!activeCycle) return;
            showConfirmModal(
                'Encerrar Ciclo Manualmente',
                'Deseja encerrar este Ciclo? Ele será contabilizado como concluído.',
                () => {
                    hideConfirmModal(); 
                    handleStartNewCycle(); 
                }
            );
        }

        function startTimer(id) { // This function is now superseded by openStartTimerModal and realStartTimer
            console.warn("`startTimer(id)` is deprecated. Use `openStartTimerModal(id)` instead.");
        }

        function stopTimer(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;
            
            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }
            
            if (doSave) saveData();
            updateDisciplinesList();
        }

        function checkCycleCompletion() {
            if (!activeCycle || activeCycle.disciplines.length === 0) return false;
            // A completude do ciclo agora depende apenas das disciplinas ATIVAS.
            return activeCycle.disciplines.filter(d => !d.isArchived).every(d => d.currentSeconds >= d.targetSeconds);
        }

        function showCompletionModal() { document.getElementById('completionModal').style.display = 'flex'; }
        function hideCompletionModal() { document.getElementById('completionModal').style.display = 'none'; }

        function handleStartNewCycle() {
            if (!activeCycle) return;
            hideCompletionModal();
            activeCycle.completions = (activeCycle.completions || 0) + 1;
            activeCycle.disciplines.forEach(d => { d.currentSeconds = 0; });
            saveData(); // Will trigger onSnapshot and update UI
            // No direct calls to updateDisplay() or showCelebrationModal() here.
            // The onSnapshot listener in loadUserData() handles the final UI state.
        }

        function handleContinueCycle() { hideCompletionModal(); }
        function showCelebrationModal() { document.getElementById('celebrationModal').style.display = 'flex'; }
        function hideCelebrationModal() { document.getElementById('celebrationModal').style.display = 'none'; }
        function showAlertModal(title, message) {
            document.getElementById('alertModalTitle').textContent = title;
            document.getElementById('alertModalMessage').textContent = message;
            document.getElementById('alertModal').style.display = 'flex';
        }
        function hideAlertModal() { document.getElementById('alertModal').style.display = 'none'; }
        
        let disciplineIdToAddTime = null; // Para armazenar o ID da disciplina que terá tempo adicionado

        function openAddTimeModal(id) {
            disciplineIdToAddTime = id;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;

            // Opcional: pré-preencher com 0, ou algum valor inicial se desejar
            document.getElementById('addTimeHoursInput').value = 0;
            document.getElementById('addTimeMinutesInput').value = 0;
            document.getElementById('addTimeSecondsInput').value = 0;
            document.getElementById('addTimeDisciplineId').value = id;
            
            document.getElementById('addTimeSubjectInput').value = '';
            // Inicializa TagAutocomplete para este modal, se ainda não foi.
            if (!addTimeTagsAutocomplete) {
                addTimeTagsAutocomplete = new TagAutocomplete('addTimeTagsInput', 'addTimeTagSuggestions');
            }
            addTimeTagsAutocomplete.setAvailableTags(Array.from(allTags)); // Garante tags atualizadas
            addTimeTagsAutocomplete.input.value = ''; // Limpa o campo
            addTimeTagsAutocomplete.filterSuggestions(''); // Força a exibição de todas as sugestões ao abrir o modal.
            document.getElementById('addTimeStopPoint').value = ''; // Nova linha: Limpa o campo
            
            populateSubjectRecommendations();
            document.getElementById('addTimeModal').style.display = 'flex';
        }

        function hideAddTimeModal() {
            document.getElementById('addTimeModal').style.display = 'none';
            disciplineIdToAddTime = null;
        }

        let currentRecordBeingEdited = null; // Armazena a referência ao registro no appData

        // openEditStudyRecordModal agora recebe o ID do registro de estudo (studyId) em vez do index
        function openEditStudyRecordModal(dateStr, cycleId, disciplineId, studyId) {
            const cycle = appData.cycles[cycleId];
            if (!cycle || !cycle.studyHistory || !cycle.studyHistory[dateStr] || !cycle.studyHistory[dateStr][disciplineId]) {
                showAlertModal('Erro', 'Registro de estudo não encontrado.');
                return;
            }
            const records = cycle.studyHistory[dateStr][disciplineId];
            
            // Encontra o registro pelo ID único
            const recordToEdit = records.find(rec => rec.id === studyId);

            if (!recordToEdit) {
                showAlertModal('Erro', 'Registro de estudo não encontrado para edição.');
                return;
            }

            currentRecordBeingEdited = recordToEdit; // Salva a referência direta ao objeto
            const discipline = cycle.disciplines.find(d => String(d.id) === disciplineId);

            // Armazena todos os IDs necessários para referenciar o registro
            document.getElementById('editRecordStudyId').value = studyId; // O ID único do registro
            document.getElementById('editRecordDateStr').value = dateStr;
            document.getElementById('editRecordDisciplineId').value = disciplineId;
            document.getElementById('editRecordCycleId').value = cycleId; // Novo campo para o CycleId

            document.getElementById('editRecordDisciplineName').value = discipline ? discipline.name : 'Desconhecida';

            const totalSeconds = currentRecordBeingEdited.time || 0;
            document.getElementById('editRecordHoursInput').value = Math.floor(totalSeconds / 3600);
            document.getElementById('editRecordMinutesInput').value = Math.floor((totalSeconds % 3600) / 60);
            document.getElementById('editRecordSecondsInput').value = Math.floor(totalSeconds % 60);
            document.getElementById('editRecordSubjectInput').value = currentRecordBeingEdited.subject || '';
            
            if (!editRecordTagsAutocomplete) {
                editRecordTagsAutocomplete = new TagAutocomplete('editRecordTagsInput', 'editRecordTagSuggestions');
            }
            editRecordTagsAutocomplete.setAvailableTags(Array.from(allTags)); 
            editRecordTagsAutocomplete.input.value = (currentRecordBeingEdited.tags || []).join(', '); 
            editRecordTagsAutocomplete.filterSuggestions(editRecordTagsAutocomplete.getCurrentTagTerm()); 
            document.getElementById('editRecordStopPoint').value = currentRecordBeingEdited.stopPoint || '';
            
            populateSubjectRecommendations();
            document.getElementById('editStudyRecordModal').style.display = 'flex';
        }

        function hideEditStudyRecordModal() {
            document.getElementById('editStudyRecordModal').style.display = 'none';
            currentRecordBeingEdited = null; // Limpa a referência
        }

        function saveEditedStudyRecord() {
            if (!currentRecordBeingEdited) {
                showAlertModal('Erro', 'Nenhum registro selecionado para edição.');
                return;
            }

            const oldTime = currentRecordBeingEdited.time || 0;

            const hours = parseInt(document.getElementById('editRecordHoursInput').value, 10) || 0;
            const minutes = parseInt(document.getElementById('editRecordMinutesInput').value, 10) || 0;
            const seconds = parseInt(document.getElementById('editRecordSecondsInput').value, 10) || 0;
            const newTime = (hours * 3600) + (minutes * 60) + seconds;

            const subject = document.getElementById('editRecordSubjectInput').value.trim();
            const tagsInput = document.getElementById('editRecordTagsInput').value.trim();
            const tags = tagsInput.split(/[, ]+/).filter(tag => tag.trim() !== '');
            const stopPoint = document.getElementById('editRecordStopPoint').value.trim();

            if (newTime <= 0) {
                showAlertModal('Tempo Inválido', 'O tempo de estudo deve ser maior que zero.');
                return;
            }

            // Atualiza as propriedades do registro diretamente
            currentRecordBeingEdited.time = newTime;
            currentRecordBeingEdited.subject = subject;
            currentRecordBeingEdited.tags = tags;
            currentRecordBeingEdited.stopPoint = stopPoint;

            // Recalcula o currentSeconds da disciplina associada
            // Pega os IDs do registro editado (que já estão nos inputs hidden)
            const cycleId = document.getElementById('editRecordCycleId').value;
            const disciplineId = document.getElementById('editRecordDisciplineId').value;
            const cycle = appData.cycles[cycleId];
            const discipline = cycle.disciplines.find(d => String(d.id) === disciplineId); // Converte para string para comparação consistente

            if (discipline) {
                // Para recalcular corretamente, somamos o tempo de TODOS os registros
                // daquela disciplina e subtraímos o tempo antigo e adicionamos o novo tempo
                let totalDisciplineTime = 0;
                if (cycle.studyHistory) {
                    Object.values(cycle.studyHistory).forEach(dailyRecords => {
                        if (dailyRecords[disciplineId]) {
                            dailyRecords[disciplineId].forEach(rec => {
                                totalDisciplineTime += rec.time || 0;
                            });
                        }
                    });
                }
                discipline.currentSeconds = totalDisciplineTime;
            }

            updateAllSubjectsAndTags(subject, tags); 

            hideEditStudyRecordModal();
            saveData(); 
            selectDate(document.getElementById('editRecordDateStr').value); // Re-renderiza o histórico do dia
            if (activeCycle && activeCycle.id === cycleId) {
                updateDisplay(); // Atualiza display da tela "Timer" se for o ciclo ativo
            }
            showAlertModal('Sucesso', 'Registro de estudo atualizado!');
        }
        
        function saveAddedTime() {
            if (!disciplineIdToAddTime || !activeCycle) {
                showAlertModal('Erro', 'Nenhuma disciplina selecionada para adicionar tempo.');
                return;
            }

            const discipline = activeCycle.disciplines.find(d => d.id === disciplineIdToAddTime);
            if (!discipline) {
                showAlertModal('Erro', 'Disciplina não encontrada.');
                return;
            }

            const hoursToAdd = parseInt(document.getElementById('addTimeHoursInput').value, 10) || 0;
            const minutesToAdd = parseInt(document.getElementById('addTimeMinutesInput').value, 10) || 0;
            const secondsToAddInput = parseInt(document.getElementById('addTimeSecondsInput').value, 10) || 0;
            const totalSecondsToAdd = (hoursToAdd * 3600) + (minutesToAdd * 60) + secondsToAddInput;
            
            const subject = document.getElementById('addTimeSubjectInput').value.trim();
            const tagsInput = document.getElementById('addTimeTagsInput').value.trim();
            const tags = tagsInput.split(/[, ]+/).filter(tag => tag.trim() !== '');

            const stopPoint = document.getElementById('addTimeStopPoint').value.trim();

            if (totalSecondsToAdd <= 0) {
                showAlertModal('Tempo Inválido', 'Por favor, insira um tempo válido (horas, minutos ou segundos) para adicionar.');
                return;
            }

            // Adiciona ao currentSeconds da disciplina
            discipline.currentSeconds += totalSecondsToAdd;

            // Atualiza o histórico de estudo do dia atual com a nova estrutura
            const today = getLocalDateString();
            if (!activeCycle.studyHistory[today]) {
                activeCycle.studyHistory[today] = {};
            }
            const discIdStr = String(discipline.id);
            if (!activeCycle.studyHistory[today][discIdStr] || !Array.isArray(activeCycle.studyHistory[today][discIdStr])) {
                activeCycle.studyHistory[today][discIdStr] = [];
            }
            activeCycle.studyHistory[today][discIdStr].push({ // Adiciona um objeto com tempo, assunto e tags
                id: Date.now() + Math.random(), // ID único para o sub-registro
                time: totalSecondsToAdd,
                subject: subject,
                tags: tags,
                timestamp: Date.now(), 
                stopPoint: stopPoint
            });
            
            // Armazena todos os assuntos e tags para recomendações futuras
            updateAllSubjectsAndTags(subject, tags);

            hideAddTimeModal();
            saveData(); 
            showAlertModal('Sucesso', `Tempo adicionado com sucesso à disciplina "${discipline.name}".`);
        }
        let selectedDateForManualAdd = null; // Armazena a data selecionada no calendário
        function openStopTimerModal(disciplineId, dateStr, recordIndex, cycleId) { // recordIndex será o studyId aqui
            const discipline = activeCycle.disciplines.find(d => d.id === disciplineId);
            if (!discipline) return;

            // Encontra a referência ao registro específico que está sendo parado
            const cycle = appData.cycles[cycleId];
            if (!cycle || !cycle.studyHistory || !cycle.studyHistory[dateStr] || !cycle.studyHistory[dateStr][disciplineId]) return;
            // Procurar pelo ID do estudo (que é passado como recordIndex)
            const studyIdToStop = recordIndex; // Renomeado para clareza
            const records = cycle.studyHistory[dateStr][disciplineId];
            
            recordToStop = records.find(rec => rec.id === studyIdToStop); // Encontra o registro pelo ID

            if (!recordToStop) {
                console.error("Registro de estudo não encontrado para parar o timer:", studyIdToStop);
                return;
            }

            document.getElementById('stopTimerDisciplineName').textContent = discipline.name;
            document.getElementById('stopTimerDisciplineId').value = disciplineId;
            document.getElementById('stopTimerStudyRecordIndex').value = recordToStop.id; // Agora armazena o ID do registro
            document.getElementById('stopTimerStudyDate').value = dateStr;
            document.getElementById('stopTimerStudyCycleId').value = cycleId;

            document.getElementById('stopTimerStopPoint').value = recordToStop.stopPoint || ''; // Preenche se já houver

            document.getElementById('stopTimerModal').style.display = 'flex';
        }

        function hideStopTimerModal() {
            document.getElementById('stopTimerModal').style.display = 'none';
            recordToStop = null;
        }

        function cancelStopTimer() {
            // Se o usuário cancelar a pausa, o timer continua rodando
            hideStopTimerModal();
        }

        function confirmStopTimer() {
            const id = parseInt(document.getElementById('stopTimerDisciplineId').value, 10);
            const stopPoint = document.getElementById('stopTimerStopPoint').value.trim();
            const studyId = parseFloat(document.getElementById('stopTimerStudyRecordIndex').value); // Converte de volta para número
            const dateStr = document.getElementById('stopTimerStudyDate').value;
            const cycleId = document.getElementById('stopTimerStudyCycleId').value;

            // Atualiza o stopPoint no registro de estudo
            const cycle = appData.cycles[cycleId];
            if (cycle && cycle.studyHistory && cycle.studyHistory[dateStr] && cycle.studyHistory[dateStr][id]) {
                const records = cycle.studyHistory[dateStr][id];
                const record = records.find(rec => rec.id === studyId);
                if (record) {
                    record.stopPoint = stopPoint;
                }
            }

            hideStopTimerModal();
            stopTimer(id, true); 
        }

        function realStopTimerForReal(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;
            
            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }
            
            if (doSave) saveData(); 
        }
        function openAddTimeToDayModal(dateStr) {
            selectedDateForManualAdd = dateStr;
            document.getElementById('addTimeToDayModalDate').textContent = new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR');
            document.getElementById('addTimeToDaySelectedDate').value = dateStr;
            
            populateAddTimeToDayCycles();
            
            // Resetar campos
            document.getElementById('addTimeToDayCycleSelect').value = '';
            document.getElementById('addTimeToDayDisciplineSelect').innerHTML = '<option value="">-- Selecione um Ciclo primeiro --</option>';
            document.getElementById('addTimeToDayHoursInput').value = 0;
            document.getElementById('addTimeToDayMinutesInput').value = 0;
            document.getElementById('addTimeToDaySecondsInput').value = 0;
            
            document.getElementById('addTimeToDaySubjectInput').value = '';
            document.getElementById('addTimeToDayTagsInput').value = '';
            document.getElementById('addTimeToDayStopPoint').value = ''; // Nova linha: Limpa o campo

            populateSubjectRecommendations();
            // Inicializa TagAutocomplete para este modal, se ainda não foi.
            if (!addTimeToDayTagsAutocomplete) {
                addTimeToDayTagsAutocomplete = new TagAutocomplete('addTimeToDayTagsInput', 'addTimeToDayTagSuggestions');
            }
            addTimeToDayTagsAutocomplete.setAvailableTags(Array.from(allTags)); // Garante tags atualizadas
            addTimeToDayTagsAutocomplete.input.value = ''; // Limpa o campo
            addTimeToDayTagsAutocomplete.filterSuggestions(''); // Força a exibição de todas as sugestões
            document.getElementById('addTimeToDayModal').style.display = 'flex';
        }

        function hideAddTimeToDayModal() {
            document.getElementById('addTimeToDayModal').style.display = 'none';
            selectedDateForManualAdd = null;
        }

        

        function populateAddTimeToDayCycles() {
            const cycleSelect = document.getElementById('addTimeToDayCycleSelect');
            cycleSelect.innerHTML = '<option value="">-- Selecione um Ciclo --</option>';
            const cycleIds = Object.keys(appData.cycles || {});
            cycleIds.forEach(id => {
                cycleSelect.innerHTML += `<option value="${id}">${id}</option>`;
            });
            // Opcional: pré-selecionar o Ciclo ativo se houver
            if (activeCycle) {
                cycleSelect.value = activeCycle.id;
                populateAddTimeToDayDisciplines(); // Popula disciplinas se um Ciclo já foi selecionado
            }
        }

        function populateAddTimeToDayDisciplines() {
            const cycleId = document.getElementById('addTimeToDayCycleSelect').value;
            const disciplineSelect = document.getElementById('addTimeToDayDisciplineSelect');
            disciplineSelect.innerHTML = '<option value="">-- Selecione uma disciplina --</option>';

            if (cycleId && appData.cycles[cycleId]) {
                const cycle = appData.cycles[cycleId];
                cycle.disciplines.forEach(d => {
                    disciplineSelect.innerHTML += `<option value="${d.id}">${d.name}</option>`;
                });
            }
        }

function saveAddTimeToDayEntry() {
            const dateStr = document.getElementById('addTimeToDaySelectedDate').value;
            const cycleId = document.getElementById('addTimeToDayCycleSelect').value;
            const disciplineId = parseInt(document.getElementById('addTimeToDayDisciplineSelect').value, 10);
            const hoursToAdd = parseInt(document.getElementById('addTimeToDayHoursInput').value, 10) || 0;
            const minutesToAdd = parseInt(document.getElementById('addTimeToDayMinutesInput').value, 10) || 0;
            const secondsToAddInput = parseInt(document.getElementById('addTimeToDaySecondsInput').value, 10) || 0;
            const totalSecondsToAdd = (hoursToAdd * 3600) + (minutesToAdd * 60) + secondsToAddInput;

            const subject = document.getElementById('addTimeToDaySubjectInput').value.trim();
            const tagsInput = document.getElementById('addTimeToDayTagsInput').value.trim();
            const tags = tagsInput.split(/[, ]+/).filter(tag => tag.trim() !== '');

            const stopPoint = document.getElementById('addTimeToDayStopPoint').value.trim(); // Nova linha

            if (!dateStr || !cycleId || !disciplineId || totalSecondsToAdd <= 0) {
                showAlertModal('Dados Inválidos', 'Por favor, preencha todos os campos e insira um tempo válido.');
                return;
            }

            const cycle = appData.cycles[cycleId];
            if (!cycle) {
                showAlertModal('Erro', 'Ciclo não encontrado.');
                return;
            }

            const discipline = cycle.disciplines.find(d => d.id === disciplineId);
            if (!discipline) {
                showAlertModal('Erro', 'Disciplina não encontrada no Ciclo selecionado.');
                return;
            }

            // Atualiza o currentSeconds da disciplina (tempo total estudado para essa disciplina)
            discipline.currentSeconds += totalSecondsToAdd;

            // Atualiza o histórico de estudo para a data específica com a nova estrutura
            if (!cycle.studyHistory[dateStr]) {
                cycle.studyHistory[dateStr] = {};
            }
            const discIdStr = String(discipline.id);
            if (!cycle.studyHistory[dateStr][discIdStr] || !Array.isArray(cycle.studyHistory[dateStr][discIdStr])) {
                cycle.studyHistory[dateStr][discIdStr] = [];
            }
            cycle.studyHistory[dateStr][discIdStr].push({ // Adiciona um objeto com tempo, assunto e tags
                id: Date.now() + Math.random(), // ID único para o sub-registro
                time: totalSecondsToAdd,
                subject: subject,
                tags: tags,
                timestamp: Date.now(),
                stopPoint: stopPoint // Nova propriedade
            });
            
            // Armazena todos os assuntos e tags para recomendações futuras
            updateAllSubjectsAndTags(subject, tags);

            hideAddTimeToDayModal();
            saveData(); 
            showAlertModal('Sucesso', `Tempo adicionado em "${discipline.name}" para ${new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR')}.`);
        }

        function showConfirmModal(title, message, callback) {
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').textContent = message;
            confirmCallback = callback;
            document.getElementById('confirmModal').style.display = 'flex';
        }
        function hideConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }
        function handleConfirmAction() {
            if (typeof confirmCallback === 'function') confirmCallback();
            hideConfirmModal();
        }
        
        function openEditModal(id) {
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;
            
            document.getElementById('editDisciplineId').value = discipline.id;
            document.getElementById('editDisciplineName').value = discipline.name;

            const hours = Math.floor(discipline.targetSeconds / 3600);
            const minutes = Math.floor((discipline.targetSeconds % 3600) / 60);
            document.getElementById('editHoursInput').value = hours;
            document.getElementById('editMinutesInput').value = minutes;

            // Carrega a cor atual da disciplina para a paleta de edição
            const currentColor = activeCycle.disciplineColors[discipline.id] || CYCLE_COLOR_PALETTE[0];
            renderDisciplineColorPalette(currentColor); // Nova chamada

            document.getElementById('editDisciplineModal').style.display = 'flex';
        }

        function hideEditModal() {
            document.getElementById('editDisciplineModal').style.display = 'none';
        }
        let disciplineIdToStartTimer = null; // Armazena o ID da disciplina para o timer

        function openStartTimerModal(id) {
            disciplineIdToStartTimer = id;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;

            document.getElementById('startTimerDisciplineName').textContent = discipline.name;
            document.getElementById('startTimerDisciplineId').value = id;
            document.getElementById('startTimerSubjectInput').value = '';
            document.getElementById('startTimerTagsInput').value = '';
            
            // Limpa o campo de ponto de parada, caso exista ou esteja em cache de alguma forma
            const stopPointInput = document.getElementById('startTimerStopPoint');
            if (stopPointInput) { 
                stopPointInput.value = '';
            }

            populateSubjectRecommendations();
            // Popula com todas as tags ao abrir o modal
            if(startTimerTagsAutocomplete) {
                startTimerTagsAutocomplete.setAvailableTags(Array.from(allTags));
                startTimerTagsAutocomplete.input.value = ''; 
                startTimerTagsAutocomplete.filterSuggestions(''); 
            }
            
            document.getElementById('startTimerModal').style.display = 'flex';
        }

        function hideStartTimerModal() {
            document.getElementById('startTimerModal').style.display = 'none';
            disciplineIdToStartTimer = null;
        }

        function confirmStartTimer() {
            const id = parseInt(document.getElementById('startTimerDisciplineId').value, 10);
            const subject = document.getElementById('startTimerSubjectInput').value.trim();
            const tagsInput = document.getElementById('startTimerTagsInput').value.trim();
            const tags = tagsInput.split(/[, ]+/).filter(tag => tag.trim() !== '');

            hideStartTimerModal(); 

            realStartTimer(id, subject, tags); 
        }

        function realStartTimer(id, subject = '', tags = []) { 
            if (!activeCycle) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline || discipline.isRunning) return;

            activeCycle.disciplines.forEach(d => { if (d.isRunning) stopTimer(d.id, false); });
            discipline.isRunning = true;
            updateDisciplinesList();

            const today = getLocalDateString();
            if (!activeCycle.studyHistory[today]) activeCycle.studyHistory[today] = {};
            const discIdStr = String(discipline.id);

            if (!activeCycle.studyHistory[today][discIdStr] || !Array.isArray(activeCycle.studyHistory[today][discIdStr])) {
                activeCycle.studyHistory[today][discIdStr] = [];
            }

            const newStudyRecord = {
                id: Date.now() + Math.random(), // ID único para o sub-registro
                time: 0, 
                subject: subject,
                tags: tags,
                timestamp: Date.now(), 
                stopPoint: '' 
            };
            activeCycle.studyHistory[today][discIdStr].push(newStudyRecord);

            updateAllSubjectsAndTags(subject, tags);

            timers[id] = setInterval(() => {
                const currentDisc = activeCycle.disciplines.find(d => d.id === id);
                if (currentDisc && activeCycle.studyHistory[today] && activeCycle.studyHistory[today][discIdStr]) {
                    const records = activeCycle.studyHistory[today][discIdStr];
                    if (records.length > 0) {
                        const lastRecord = records[records.length - 1];
                        lastRecord.time += 1; 
                        currentDisc.currentSeconds += 1; 
                        updateTimerDisplay(currentDisc);
                    }
                }
            }, 1000);
        }

        function stopTimer(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;
            
            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }
            
            if (doSave) saveData();
            updateDisciplinesList();
        }

        function saveDisciplineChanges() {
            const id = parseInt(document.getElementById('editDisciplineId').value, 10);
            const newName = document.getElementById('editDisciplineName').value.trim();
            const newHours = parseInt(document.getElementById('editHoursInput').value, 10) || 0;
            const newMinutes = parseInt(document.getElementById('editMinutesInput').value, 10) || 0;
            const newTargetSeconds = (newHours * 3600) + (newMinutes * 60);

            if (!newName || newTargetSeconds <= 0) {
                showAlertModal('Dados Inválidos', 'O nome e a meta de tempo devem ser válidos.');
                return;
            }

            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (discipline) {
                discipline.name = newName;
                discipline.targetSeconds = newTargetSeconds;
                // Salva a nova cor da disciplina
                if (activeCycle.disciplineColors) {
                    activeCycle.disciplineColors[discipline.id] = selectedEditDisciplineColor;
                }
                saveData(); 
                updateDisplay();
                hideEditModal();
            }
        }

        function toggleTimer(id) {
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;
            if (discipline.isRunning) {
                const today = getLocalDateString();
                const discIdStr = String(discipline.id);
                
                // Pega o último registro adicionado (que deve ser o ativo)
                const records = activeCycle.studyHistory[today] && activeCycle.studyHistory[today][discIdStr] ? activeCycle.studyHistory[today][discIdStr] : [];
                const lastRecord = records.length > 0 ? records[records.length - 1] : null;

                if (lastRecord && lastRecord.id) { // Verifica se há um último registro e se ele tem um ID
                    openStopTimerModal(id, today, lastRecord.id, activeCycle.id); // Passa o ID do registro
                } else {
                    stopTimer(id, true);
                }
            } else {
                openStartTimerModal(id);
            }
        }

        function switchView(viewName) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${viewName}-view`).classList.add('active');
            
            const sidebar = document.querySelector('.sidebar-nav');
            const mainContent = document.querySelector('.main-content');
            if (viewName === 'login' || viewName === 'loading') {
                 sidebar.style.display = 'none';
                 mainContent.style.marginLeft = '0';
            } else {
                sidebar.style.display = 'flex';
                mainContent.style.marginLeft = getComputedStyle(sidebar).width;
                document.querySelectorAll('.sidebar-menu li').forEach(t => t.classList.remove('active'));
                const activeTab = document.querySelector(`.sidebar-menu li[data-view='${viewName}']`);
                if(activeTab) activeTab.classList.add('active');
            }
            
            if (viewName === 'calendar') renderCalendar();
            if (viewName === 'reports') {
                if (!reportsInitialized) initializeReportFilters();
                renderReportsView(); 
            }
            if (viewName === 'tags') { 
                activeTagFilter = ''; // Reseta o filtro de tags ao entrar na view
                document.getElementById('tagSearchInput').value = ''; // Limpa a busca textual
                renderAllTags();
                filterTagsAndStudies(); // Carrega todos os estudos inicialmente ou com filtro padrão
            }
        }

        function updateDisplay() {
            if (!activeCycle) return; 
            document.getElementById('cycleTitleText').textContent = `Ciclo: ${activeCycle.id}`;
            updateStats();
            updateDisciplinesList();
            createWheelChart();
        }
        
function updateStats() {
            if (!activeCycle) return;

            document.getElementById('cycleCompletions').textContent = activeCycle.completions || 0;
            // O total de disciplinas agora considera apenas as ativas para este contador
            document.getElementById('totalDisciplines').textContent = activeCycle.disciplines.filter(d => !d.isArchived).length;

            const today = getLocalDateString();
            let totalSecondsStudiedTodayAllCycles = 0;

            // Itera sobre TODOS os ciclos do appData
            if (appData.cycles) {
                for (const cycleId in appData.cycles) {
                    const cycle = appData.cycles[cycleId];
                    if (cycle.studyHistory && cycle.studyHistory[today]) {
                        // Itera sobre cada entrada de disciplina no histórico do dia
                        Object.values(cycle.studyHistory[today]).forEach(disciplineRecords => {
                            // disciplineRecords é agora um ARRAY de objetos de estudo
                            if (Array.isArray(disciplineRecords)) {
                                totalSecondsStudiedTodayAllCycles += disciplineRecords.reduce((sum, record) => {
                                    return sum + (record.time || 0); // Soma a propriedade 'time' de cada registro
                                }, 0);
                            }
                        });
                    }
                }
            }

            // Atualiza o display das horas estudadas hoje
            document.getElementById('totalHours').textContent = formatTime(totalSecondsStudiedTodayAllCycles);
        }

        function updateDisciplinesList() {
            if (!activeCycle) return;
            const activeListEl = document.getElementById('disciplinesList');
            const archivedListEl = document.getElementById('archivedDisciplinesList');
            if (!activeListEl || !archivedListEl) return;

            activeListEl.innerHTML = '';
            archivedListEl.innerHTML = '';

            const activeDisciplines = activeCycle.disciplines.filter(d => !d.isArchived);
            const archivedDisciplines = activeCycle.disciplines.filter(d => d.isArchived);

            if (activeDisciplines.length === 0 && archivedDisciplines.length === 0) {
                activeListEl.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhuma disciplina adicionada ainda.</p>';
                return;
            }

            activeDisciplines.forEach(d => {
                const isCompleted = d.targetSeconds > 0 && d.currentSeconds >= d.targetSeconds;
                const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                activeListEl.innerHTML += `
                    <div class="discipline-item ${isCompleted ? 'completed' : ''}" id="discipline-${d.id}" style="border-left-color: ${disciplineColor};">
                        <div class="discipline-name-group">
                            <button class="edit-btn" title="Editar disciplina" onclick="openEditModal(${d.id})"><span class="material-icons-outlined">edit</span></button>
                            <span>${d.name}</span>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center; min-width: 100px;">
                            <span class="time-current">${formatTime(d.currentSeconds)}</span>
                            <span style="font-size: 12px; color: #666;">Meta: ${formatTime(d.targetSeconds)}</span>
                        </div>
                        <div class="timer-controls" style="display:flex; gap:8px; align-items:center;">
                            <button class="timer-btn ${d.isRunning ? 'stop' : ''}" onclick="toggleTimer(${d.id})">${d.isRunning ? 'Pausar' : 'Iniciar'}</button>
                            <button class="secondary" onclick="openAddTimeModal(${d.id})">Add Tempo</button>
                            <button class="secondary" onclick="toggleArchiveDiscipline(${d.id})">Arquivar</button>
                            <button class="remove-btn danger" onclick="removeDiscipline(${d.id})">Remover</button>
                        </div>
                    </div>`;
            });

            if (archivedDisciplines.length === 0) {
                archivedListEl.innerHTML = '<p style="text-align:center; padding: 10px; color: #6c757d;">Nenhuma disciplina arquivada.</p>';
            } else {
                archivedDisciplines.forEach(d => {
                    const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                    archivedListEl.innerHTML += `
                        <div class="discipline-item archived" id="discipline-${d.id}" style="border-left-color: ${disciplineColor}; opacity: 0.7;">
                            <div class="discipline-name-group">
                                <button class="edit-btn" title="Editar disciplina" onclick="openEditModal(${d.id})"><span class="material-icons-outlined">edit</span></button>
                                <span>${d.name} (Arquivada)</span>
                            </div>
                            <div style="display: flex; flex-direction: column; align-items: center; min-width: 100px;">
                                <span class="time-current">${formatTime(d.currentSeconds)}</span>
                                <span style="font-size: 12px; color: #666;">Meta: ${formatTime(d.targetSeconds)}</span>
                            </div>
                            <div class="timer-controls" style="display:flex; gap:8px; align-items:center;">
                                <button class="secondary" onclick="toggleArchiveDiscipline(${d.id})">Desarquivar</button>
                                <button class="remove-btn danger" onclick="removeDiscipline(${d.id})">Remover</button>
                            </div>
                        </div>`;
                });
            }
        }
        
        // Nova função para arquivar/desarquivar disciplinas
        function toggleArchiveDiscipline(id) {
            if (!activeCycle) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (discipline) {
                discipline.isArchived = !discipline.isArchived; // Alterna o estado
                
                // Se a disciplina for arquivada e estiver rodando um timer, pare-o
                if (discipline.isArchived && timers[id]) {
                    stopTimer(id, false); // Pare o timer sem salvar novamente, pois saveData será chamado logo em seguida
                }

                saveData(); // Salva a alteração
                updateDisciplinesList(); // Atualiza a lista para refletir a mudança
                showAlertModal('Disciplina Arquivada', `A disciplina "${discipline.name}" foi ${discipline.isArchived ? 'arquivada' : 'desarquivada'}.`);
            }
        }

        function updateTimerDisplay(discipline) {
            const itemEl = document.getElementById(`discipline-${discipline.id}`);
            if (!itemEl) return;
            itemEl.querySelector('.time-current').textContent = formatTime(discipline.currentSeconds);
            const isCompleted = discipline.targetSeconds > 0 && discipline.currentSeconds >= discipline.targetSeconds;
            if(isCompleted) { itemEl.classList.add('completed'); } 
            else { itemEl.classList.remove('completed'); }
            updateStats();
        }

        function createWheelChart() {
            const svg = document.getElementById('wheelChart');
            const tooltip = document.getElementById('tooltip');
            svg.innerHTML = ''; 
            if (!activeCycle || activeCycle.disciplines.length === 0) {
                svg.innerHTML = `<text x="200" y="200" text-anchor="middle" font-size="16">Adicione disciplinas para começar</text>`;
                return;
            }
            
            const activeDisciplines = activeCycle.disciplines.filter(d => !d.isArchived); // Considera apenas disciplinas ativas para o gráfico
            const totalStudied = activeDisciplines.reduce((sum, d) => sum + d.currentSeconds, 0);
            const totalTarget = activeDisciplines.reduce((sum, d) => sum + d.targetSeconds, 0);
            let startAngle = -90;
            const gapDegrees = 2;

            if (totalTarget === 0 && activeDisciplines.length > 0) {
                const equalSliceAngle = 360 / activeDisciplines.length;
                activeDisciplines.forEach((d, i) => {
                    let sliceAngle = equalSliceAngle;
                    let endAngle = startAngle + sliceAngle;
                    if (sliceAngle > gapDegrees) {
                        const arcStart = startAngle + gapDegrees / 2;
                        const arcEnd = endAngle - gapDegrees / 2;
                        const path = createArc(200, 200, 150, 90, arcStart, arcEnd);
                        const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                        path.setAttribute("fill", disciplineColor);
                        path.addEventListener('mouseover', (e) => {
                            tooltip.innerHTML = `<strong>${d.name}</strong><br>Estudado: ${formatTime(d.currentSeconds)}<br>Meta: ${formatTime(d.targetSeconds)}`;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${e.clientX + 15}px`;
                            tooltip.style.top = `${e.clientY - 10}px`;
                        });
                        path.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
                        svg.appendChild(path);
                    }
                    startAngle = endAngle;
                });
            } else {
                activeDisciplines.forEach((d, i) => {
                    let sliceAngle = totalTarget > 0 ? (d.targetSeconds / totalTarget) * 360 : 0;
                    if (sliceAngle === 0 && d.targetSeconds > 0) {
                        sliceAngle = 360 / activeDisciplines.length;
                    }
                    let endAngle = startAngle + sliceAngle;

                    if (sliceAngle > gapDegrees) {
                        const arcStart = startAngle + gapDegrees / 2;
                        const arcEnd = endAngle - gapDegrees / 2;
                        const path = createArc(200, 200, 150, 90, arcStart, arcEnd);
                        const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                        path.setAttribute("fill", disciplineColor);
                        path.addEventListener('mouseover', (e) => {
                            tooltip.innerHTML = `<strong>${d.name}</strong><br>Estudado: ${formatTime(d.currentSeconds)}<br>Meta: ${formatTime(d.targetSeconds)}`;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${e.clientX + 15}px`;
                            tooltip.style.top = `${e.clientY - 10}px`;
                        });
                        path.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
                        svg.appendChild(path);
                    }
                    startAngle = endAngle;
                });
            }

            const svgNS = "http://www.w3.org/2000/svg";
            function createText(x, y, content, size, weight, color, opacity = 1) {
                const textEl = document.createElementNS(svgNS, "text");
                textEl.setAttribute("x", x); textEl.setAttribute("y", y);
                textEl.setAttribute("text-anchor", "middle");
                textEl.setAttribute("font-size", size);
                if (weight) textEl.setAttribute("font-weight", weight);
                textEl.setAttribute("fill", color);
                textEl.setAttribute("opacity", opacity);
                textEl.textContent = content;
                return textEl;
            }
            
            svg.appendChild(createText("200", "185", "Estudei", "18", "500", "#6c757d"));
            svg.appendChild(createText("200", "215", formatTime(totalStudied), "28", "600", "#0d253f"));
            svg.appendChild(createText("200", "238", `de ${formatTime(totalTarget)}`, "16", "500", "#6c757d", 0.8));
        }

        function createArc(x, y, outerR, innerR, start, end) {
            if (end - start >= 360) end = start + 359.99;
            const startRad = (start * Math.PI) / 180, endRad = (end * Math.PI) / 180;
            const largeArc = (end - start) > 180 ? 1 : 0;
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            const d = ["M",x + outerR * Math.cos(startRad),y + outerR * Math.sin(startRad),"A",outerR,outerR,0,largeArc,1,x + outerR * Math.cos(endRad),y + outerR * Math.sin(endRad),"L",x + innerR * Math.cos(endRad),y + innerR * Math.sin(endRad),"A",innerR,innerR,0,largeArc,0,x + innerR * Math.cos(startRad),y + innerR * Math.sin(startRad),"Z"].join(" ");
            p.setAttribute("d", d);
            return p;
        }
        
        function setCalendarView(mode) {
            calendarViewMode = mode;
            document.getElementById('view-toggle-month').classList.toggle('active', mode === 'month');
            document.getElementById('view-toggle-week').classList.toggle('active', mode === 'week');
            renderCalendar();
        }

        function navigateCalendar(direction) {
            if (calendarViewMode === 'month') {
                currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
            } else {
                currentCalendarDate.setDate(currentCalendarDate.getDate() + (direction * 7));
            }
            renderCalendar();
        }

        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            const titleEl = document.getElementById('calendarTitle');
            const summaryEl = document.getElementById('calendar-summary');
            grid.innerHTML = '';
            
            const allHistories = Object.values(appData.cycles).map(c => c.studyHistory).filter(Boolean);

            if (calendarViewMode === 'month') {
                const year = currentCalendarDate.getFullYear();
                const month = currentCalendarDate.getMonth();
                titleEl.textContent = `${currentCalendarDate.toLocaleString('pt-BR', { month: 'long', year: 'numeric' })}`;
                
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                let monthlyTotalSeconds = 0;

                for (let i = 0; i < firstDayOfMonth; i++) { grid.insertAdjacentHTML('beforeend', '<div></div>'); }

                for (let i = 1; i <= daysInMonth; i++) {
                    const date = new Date(year, month, i);
                    const isoDate = getLocalDateString(date);
                    let dailyTotal = 0;
                    allHistories.forEach(history => {
                        if (history[isoDate]) {
                            // Soma o tempo de todos os registros de estudo para este dia
                            Object.values(history[isoDate]).forEach(disciplineRecords => {
                                if (Array.isArray(disciplineRecords)) {
                                    dailyTotal += disciplineRecords.reduce((sum, record) => sum + (record.time || 0), 0);
                                }
                            });
                        }
                    });
                    monthlyTotalSeconds += dailyTotal;

                    let classes = 'calendar-day';
                    if (isoDate === getLocalDateString()) classes += ' today';
                    if (selectedDate === isoDate) classes += ' selected';
                    let statusIcon = '';
                    if (dailyTotal > 0) {
                        statusIcon = '<span class="material-icons-outlined status-icon status-success">check_circle</span>';
                        classes += ' has-studies'; // Manter esta classe para estilos futuros se necessário
                    } else {
                        // Se não houver estudos para o dia E for um dia que não está no futuro
                        const todayLocal = new Date(getLocalDateString() + 'T12:00:00');
                        const currentDateLocal = new Date(isoDate + 'T12:00:00');
                        if (currentDateLocal < todayLocal) { // Apenas adiciona o 'X' para dias passados sem estudo
                            statusIcon = '<span class="material-icons-outlined status-icon status-danger">cancel</span>';
                        }
                    }

                    // Adicione a classe 'active-day' para ter estilos mais específicos
                    grid.insertAdjacentHTML('beforeend', `
                        <div class="calendar-day active-day ${classes}" onclick="selectDate('${isoDate}')">
                            <span class="day-number">${i}</span>
                            ${statusIcon}
                        </div>
                    `);
                }
                summaryEl.innerHTML = `Total no Mês: <strong>${formatTime(monthlyTotalSeconds)}</strong>`;

            } else { // 'week' view
                const weekStart = new Date(currentCalendarDate);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 6);

                titleEl.textContent = `${weekStart.toLocaleDateString('pt-BR')} - ${weekEnd.toLocaleDateString('pt-BR')}`;
                let weeklyTotalSeconds = 0;

                for (let i = 0; i < 7; i++) {
                    const date = new Date(weekStart);
                    date.setDate(date.getDate() + i);
                    const isoDate = getLocalDateString(date);
                    let dailyTotal = 0;
                     allHistories.forEach(history => {
                        if (history[isoDate]) {
                            // Soma o tempo de todos os registros de estudo para este dia
                            Object.values(history[isoDate]).forEach(disciplineRecords => {
                                if (Array.isArray(disciplineRecords)) {
                                    dailyTotal += disciplineRecords.reduce((sum, record) => sum + (record.time || 0), 0);
                                }
                            });
                        }
                    });
                    weeklyTotalSeconds += dailyTotal;

                    let classes = 'calendar-day';
                    if (isoDate === getLocalDateString()) classes += ' today';
                    if (selectedDate === isoDate) classes += ' selected';
                    let statusIcon = '';
                    if (dailyTotal > 0) {
                        statusIcon = '<span class="material-icons-outlined status-icon status-success">check_circle</span>';
                        classes += ' has-studies';
                    } else {
                        // Se não houver estudos para o dia E for um dia que não está no futuro
                        const todayLocal = new Date(getLocalDateString() + 'T12:00:00');
                        const currentDateLocal = new Date(isoDate + 'T12:00:00');
                        if (currentDateLocal < todayLocal) { // Apenas adiciona o 'X' para dias passados sem estudo
                            statusIcon = '<span class="material-icons-outlined status-icon status-danger">cancel</span>';
                        }
                    }

                    grid.insertAdjacentHTML('beforeend', `
                        <div class="calendar-day active-day ${classes}" onclick="selectDate('${isoDate}')">
                            <span class="day-number">${date.getDate()}</span>
                            ${statusIcon}
                        </div>
                    `);
                }
                 summaryEl.innerHTML = `Total na Semana: <strong>${formatTime(weeklyTotalSeconds)}</strong>`;
            }
        }

       function selectDate(dateStr) {
            selectedDate = dateStr;
            renderCalendar(); 
            const infoEl = document.getElementById('selectedDateInfo');
            
            let dailyTotalSeconds = 0;
            let html = `<h4 style="color: #0d253f; font-weight: 600;">Estudos de ${new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR')}</h4>`;
            let studiesFound = false;

            const recordsForDay = []; // Array para coletar e ordenar todos os registros do dia
            Object.values(appData.cycles).forEach(cycle => {
                if (cycle.studyHistory && cycle.studyHistory[dateStr]) {
                    Object.entries(cycle.studyHistory[dateStr]).forEach(([discId, recordsArray]) => {
                        if (Array.isArray(recordsArray)) {
                            recordsArray.forEach(record => {
                                // Adiciona informações necessárias para exibição e edição/exclusão
                                recordsForDay.push({
                                    ...record,
                                    cycleId: cycle.id,
                                    disciplineId: discId, // Garante que o ID da disciplina está no registro
                                    cycleName: cycle.id, // Adiciona o nome do ciclo
                                    disciplineName: cycle.disciplines.find(d => String(d.id) === discId)?.name // Adiciona o nome da disciplina
                                });
                            });
                        }
                    });
                }
            });

            // Ordena os registros do dia pelo timestamp
            recordsForDay.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

            recordsForDay.forEach((record) => { // Removido 'index' pois usaremos 'record.id' para editar/excluir
                const recordTime = record.timestamp ? formatTimestampToHHMM(record.timestamp) : '';
                const displayDisciplineName = record.disciplineName || 'Disciplina Desconhecida';
                const displayCycleName = record.cycleName || 'Ciclo Desconhecido';

                html += `<div class="study-history-item"> 
                            <span>
                                <strong>${displayDisciplineName}</strong> (${displayCycleName})${recordTime ? ` às ${recordTime}` : ''}: ${formatTime(record.time || 0)}
                                ${record.subject ? `<br><small>Assunto: ${record.subject}</small>` : ''}
                                ${record.tags && record.tags.length > 0 ? `<br><small>Tags: ${record.tags.join(', ')}</small>` : ''}
                                ${record.stopPoint ? `<br><small>Parada: ${record.stopPoint}</small>` : ''} 
                            </span> 
                            <div style="display: flex; gap: 5px;">
                                <button class="edit-btn secondary" title="Editar este registro" onclick="openEditStudyRecordModal('${dateStr}', '${record.cycleId}', '${record.disciplineId}', ${record.id})">Editar</button> <button class="history-delete-btn" title="Apagar este registro" onclick="deleteHistoryEntry('${dateStr}', '${record.cycleId}', '${record.disciplineId}', ${record.id})">X</button> 
                            </div>
                        </div>`;
                studiesFound = true;
                dailyTotalSeconds += (record.time || 0);
            });

            const summaryHtml = `<div class="daily-total" style="display: flex; justify-content: space-between; align-items: center;">
                                    <span><strong>Total do Dia:</strong> ${formatTime(dailyTotalSeconds)}</span>
                                    <button class="secondary" onclick="openAddTimeToDayModal('${dateStr}')">Adicionar Tempo</button>
                                </div>`;

            if (!studiesFound) {
                html += `<p style="margin-top: 10px;">Nenhum estudo registrado para este dia.</p>`;
                infoEl.innerHTML = summaryHtml + html;
            } else {
                infoEl.innerHTML = summaryHtml + html;
            }
            infoEl.style.display = 'block';
        }
        
       // deleteHistoryEntry agora recebe o ID único do registro de estudo (studyId)
       function deleteHistoryEntry(dateStr, cycleId, disciplineId, studyId) { 
            showConfirmModal('Apagar Registro', 'Tem certeza? O tempo total da disciplina será recalculado.', () => {
                const cycle = appData.cycles[cycleId];
                if (!cycle || !cycle.studyHistory || !cycle.studyHistory[dateStr] || !cycle.studyHistory[dateStr][disciplineId]) {
                    console.error("Registro não encontrado para exclusão. Data:", dateStr, "Ciclo:", cycleId, "Disciplina:", disciplineId, "Study ID:", studyId);
                    return;
                }
                
                let records = cycle.studyHistory[dateStr][disciplineId];
                
                // Encontra o índice do registro com base no studyId
                const recordIndexToDelete = records.findIndex(record => record.id === studyId);

                if (recordIndexToDelete === -1) {
                    console.error("Registro com ID único não encontrado para exclusão:", studyId);
                    return;
                }

                const secondsToDelete = records[recordIndexToDelete].time || 0; 
                
                // Remove o registro do array
                records.splice(recordIndexToDelete, 1); 

                // Atualiza o currentSeconds da disciplina
                const discipline = cycle.disciplines.find(d => String(d.id) === disciplineId);
                if (discipline) {
                    // Recalcula o tempo total da disciplina somando todos os registros restantes
                    let totalTimeRemaining = 0;
                    Object.values(cycle.studyHistory).forEach(dailyRecords => {
                        if (dailyRecords[disciplineId]) {
                            dailyRecords[disciplineId].forEach(rec => {
                                totalTimeRemaining += rec.time || 0;
                            });
                        }
                    });
                    discipline.currentSeconds = totalTimeRemaining;
                }

                if (records.length === 0) {
                    delete cycle.studyHistory[dateStr][disciplineId];
                }
                
                if (Object.keys(cycle.studyHistory[dateStr]).length === 0) {
                    delete cycle.studyHistory[dateStr];
                }

                saveData(); 
                selectDate(dateStr); // Re-renderiza o histórico do dia
                if (activeCycle && activeCycle.id === cycleId) {
                    updateDisplay(); // Atualiza display da tela "Timer" se for o ciclo ativo
                }
                renderReportsView(); // Atualiza relatórios após exclusão
            });
        }
        
        function initializeReportFilters() {
            const today = new Date();
            // Calcula o início da semana (Domingo)
            reportStartDate = new Date(today);
            reportStartDate.setDate(today.getDate() - today.getDay()); 
            reportStartDate.setHours(0, 0, 0, 0); // Zera hora para o início do dia

            // Calcula o fim da semana (Sábado)
            reportEndDate = new Date(reportStartDate);
            reportEndDate.setDate(reportStartDate.getDate() + 6);
            reportEndDate.setHours(23, 59, 59, 999); // Ajusta para o final do dia

            if (typeof Litepicker !== 'undefined') {
                reportDatePicker = new Litepicker({
                    element: document.getElementById('report-date-input'),
                    singleMode: false, allowRepick: true, lang: "pt-BR",
                    lexicon: {"button_previous": "❮", "button_next": "❯", "button_apply": "Aplicar", "button_cancel": "Cancelar", "months": ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], "weekdays": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"]},
                    format: 'DD/MM/YYYY', startDate: reportStartDate, endDate: reportEndDate,
                    setup: (picker) => {
                        picker.on('selected', (date1, date2) => {
                            // Normaliza as datas para o início e fim do dia selecionado
                            reportStartDate = new Date(date1.dateInstance.getFullYear(), date1.dateInstance.getMonth(), date1.dateInstance.getDate());
                            reportEndDate = new Date(date2.dateInstance.getFullYear(), date2.dateInstance.getMonth(), date2.dateInstance.getDate(), 23, 59, 59, 999);
                            renderReportsView();
                        });
                    }
                });
            } else {
                console.error("Litepicker não está definido.");
            }
            populateCycleFilter();
            reportsInitialized = true;
        }

        function populateCycleFilter() {
            const selector = document.getElementById('report-cycle-filter');
            selector.innerHTML = '<option value="all">Todos os Ciclos</option>';
            Object.keys(appData.cycles || {}).forEach(id => selector.innerHTML += `<option value="${id}">${id}</option>`);
        }

        function renderReportsView() {
            if (!reportsInitialized) return;
            const selectedCycle = document.getElementById('report-cycle-filter').value;
            const reportData = processReportData(reportStartDate, reportEndDate, selectedCycle);
            
            document.getElementById('report-total-hours').textContent = formatTime(reportData.totalSeconds);
            document.getElementById('report-daily-average').textContent = formatTime(reportData.dailyAverage);

            renderDurationBarChart(reportData.durationByDay);
            renderDistributionDonutChart(reportData.distributionByCycle);
            renderBreakdownTable(reportData.breakdown, reportData.totalSeconds);
        }

        function processReportData(startDate, endDate, selectedCycle) {
            let totalSeconds = 0;
            const durationByDay = {}; 
            const distributionByCycle = {};
            const breakdown = {};

            const normalizedStartDateISO = getLocalDateString(startDate);
            const normalizedEndDateISO = getLocalDateString(endDate);

            // Popula durationByDay com todos os dias do período e inicializa com 0 para cada ciclo
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = getLocalDateString(d);
                durationByDay[dateStr] = {};

                Object.values(appData.cycles).forEach(cycle => {
                    // Inclui disciplinas arquivadas no relatório por padrão
                    if (selectedCycle === 'all' || cycle.id === selectedCycle) {
                        durationByDay[dateStr][cycle.id] = 0; 
                    }
                });
            }


            Object.values(appData.cycles).forEach(cycle => {
                if (selectedCycle !== 'all' && cycle.id !== selectedCycle) return;
                if (!cycle.studyHistory) return;

                Object.entries(cycle.studyHistory).forEach(([dateStr, disciplineEntries]) => {
                    // Verifica se a data do histórico está dentro do período selecionado
                    if (dateStr >= normalizedStartDateISO && dateStr <= normalizedEndDateISO) {
                        Object.entries(disciplineEntries).forEach(([discId, records]) => {
                            if (Array.isArray(records)) {
                                records.forEach(record => {
                                    const seconds = record.time || 0;
                                    
                                    // Adiciona tempo para o dia e ciclo específico
                                    if (!durationByDay[dateStr][cycle.id]) {
                                        durationByDay[dateStr][cycle.id] = 0; // Garante inicialização
                                    }
                                    durationByDay[dateStr][cycle.id] += seconds;

                                    // Atualiza a distribuição geral por ciclo
                                    distributionByCycle[cycle.id] = (distributionByCycle[cycle.id] || 0) + seconds;

                                    // Atualiza a estrutura de detalhamento (breakdown)
                                    if (!breakdown[cycle.id]) breakdown[cycle.id] = { totalSeconds: 0, disciplines: {} };
                                    breakdown[cycle.id].totalSeconds += seconds;
                                    breakdown[cycle.id].disciplines[discId] = (breakdown[cycle.id].disciplines[discId] || 0) + seconds;
                                });
                            }
                        });
                        // Soma para o total geral do período (este é o total dos estudos visíveis no relatório)
                        totalSeconds += Object.values(disciplineEntries).flat().reduce((sum, rec) => sum + (rec.time || 0), 0);
                    }
                });
            });

            // Recalcula actualStudyDays com base nos dias que realmente tiveram estudo no período e filtros
            let actualStudyDays = 0;
            for(const dateStr in durationByDay) {
                let dayHasStudy = false;
                for(const cycleId in durationByDay[dateStr]) {
                    if (durationByDay[dateStr][cycleId] > 0) {
                        dayHasStudy = true;
                        break;
                    }
                }
                if (dayHasStudy) {
                    actualStudyDays++;
                }
            }

            const dailyAverage = actualStudyDays > 0 ? totalSeconds / actualStudyDays : 0;
            return { totalSeconds, dailyAverage, durationByDay, distributionByCycle, breakdown };
        }

       function renderDurationBarChart(data) {
            const ctx = document.getElementById('durationBarChart');
            if (!ctx) return;
            const context = ctx.getContext('2d');

            const allDatesInPeriod = [];
            let currentDate = new Date(reportStartDate);
            while (currentDate <= reportEndDate) {
                allDatesInPeriod.push(getLocalDateString(currentDate));
                currentDate.setDate(currentDate.getDate() + 1);
            }
            allDatesInPeriod.sort(); 

            const chartLabels = allDatesInPeriod.map(dateStr => {
                const date = new Date(dateStr + 'T12:00:00'); 
                return date.toLocaleDateString('pt-BR', { weekday: 'short', day: 'numeric' }); 
            });

            const allCycleIds = new Set();
            Object.values(appData.cycles).forEach(cycle => allCycleIds.add(cycle.id));

            const datasets = Array.from(allCycleIds).map(cycleId => {
                const cycle = appData.cycles[cycleId];
                const cycleColor = cycle ? cycle.color : '#CCCCCC'; 
                const datasetData = allDatesInPeriod.map(dateStr => { 
                    return data[dateStr] && data[dateStr][cycleId] ? data[dateStr][cycleId] : 0;
                });
                return {
                    label: cycle.id, 
                    data: datasetData,
                    backgroundColor: cycleColor,
                    borderRadius: 4,
                    stack: 'dailyStudies', 
                };
            });
            
            if (durationBarChart) durationBarChart.destroy();
            if (typeof Chart === 'undefined') { console.error("Chart.js não está definido."); return; }
            durationBarChart = new Chart(context, {
                type: 'bar',
                data: { labels: chartLabels, datasets: datasets }, 
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { 
                        x: { 
                            type: 'category', 
                            stacked: true, 
                            grid: { display: false } 
                        }, 
                        y: { 
                            beginAtZero: true, 
                            stacked: true, 
                            ticks: { callback: (value) => formatTime(value).substring(0, 5) } 
                        } 
                    },
                    plugins: { 
                        legend: { display: true, position: 'top' }, 
                        tooltip: { 
                            mode: 'index', 
                            intersect: false, 
                            callbacks: { 
                                label: (ctx) => `${ctx.dataset.label}: ${formatTime(ctx.raw)}` 
                            } 
                        } 
                    }
                }
            });
        }

        const doughnutText = {
            id: 'doughnutText',
            afterDraw(chart, args, options) {
                const { ctx } = chart; if (!options.text) return;
                const meta = chart.getDatasetMeta(0);
                if (!meta.data || meta.data.length === 0) return;
                const { total, label } = options.text;
                ctx.save();
                const x = meta.data[0].x; const y = meta.data[0].y;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = '500 1em Poppins'; ctx.fillStyle = '#6c757d';
                ctx.fillText(label, x, y - 12);
                ctx.font = '600 1.5em Poppins'; ctx.fillStyle = '#0d253f';
                ctx.fillText(total, x, y + 15);
                ctx.restore();
            }
        };

        function renderDistributionDonutChart(data) {
            const ctx = document.getElementById('distributionDonutChart');
            if (!ctx) return;
            const context = ctx.getContext('2d');
            
            const labels = Object.keys(data).filter(cycleId => data[cycleId] > 0);
            const values = labels.map(cycleId => data[cycleId]);
            
            const backgroundColors = labels.map(cycleId => {
                const cycle = appData.cycles[cycleId];
                return cycle ? cycle.color : '#CCCCCC'; 
            });
            
            const totalSecondsInChart = values.reduce((sum, value) => sum + value, 0);
            const formattedTotalTime = formatTime(totalSecondsInChart);
            
            if (distributionDonutChart) distributionDonutChart.destroy();
            if (typeof Chart === 'undefined') { console.error("Chart.js não está definido."); return; }
            
            distributionDonutChart = new Chart(context, {
                type: 'doughnut',
                data: { labels: labels, datasets: [{ data: values, backgroundColor: backgroundColors, borderColor: '#fff', borderWidth: 2 }] },
                options: {
                    responsive: true, maintainAspectRatio: false, cutout: '70%',
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { 
                            callbacks: { 
                                label: (c) => `${c.label}: ${formatTime(c.raw)} (${(c.raw / c.chart.getDatasetMeta(0).total * 100).toFixed(1)}%)` 
                            } 
                        }, 
                        doughnutText: { text: { total: formattedTotalTime, label: 'Total' } } 
                    }
                },
                plugins: [doughnutText]
            });
        }

        function renderBreakdownTable(data, totalSeconds) {
            const tableBody = document.getElementById('breakdown-table-body');
            tableBody.innerHTML = '';
            
            const cyclesWithStudy = Object.entries(data).filter(([, cycleData]) => cycleData.totalSeconds > 0);

            if (cyclesWithStudy.length === 0) {
                tableBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum dado para o período.</p>';
                return;
            }

            const sortedCycles = cyclesWithStudy.sort((a, b) => b[1].totalSeconds - a[1].totalSeconds);

            for (const [cycleId, cycleData] of sortedCycles) {
                const cycle = appData.cycles[cycleId];
                if (!cycle) continue; 

                const percentage = totalSeconds > 0 ? ((cycleData.totalSeconds / totalSeconds) * 100).toFixed(1) : 0;
                
                const cycleColor = cycle.color || '#CCCCCC'; 
                
                const cycleRow = document.createElement('div');
                cycleRow.className = 'breakdown-row cycle-row';
                cycleRow.setAttribute('onclick', `toggleCycleDetails(this)`);
                cycleRow.innerHTML = `<div class="cycle-name-cell"><span class="material-icons-outlined toggle-arrow">chevron_right</span><span class="cycle-color-dot" style="background-color:${cycleColor};"></span><span>${cycleId}</span></div><span class="d-right">${formatTime(cycleData.totalSeconds)}</span><span class="d-right">${percentage}%</span>`;
                tableBody.appendChild(cycleRow);
                const disciplinesWrapper = document.createElement('div');
                disciplinesWrapper.className = 'discipline-rows-wrapper';
                const sortedDisciplines = Object.entries(cycleData.disciplines).sort((a, b) => b[1] - a[1]);
                for (const [discId, discSeconds] of sortedDisciplines) {
                    const discipline = cycle.disciplines.find(d => String(d.id) === discId);
                    if (discipline) {
                        const discPercentage = cycleData.totalSeconds > 0 ? ((discSeconds / cycleData.totalSeconds) * 100).toFixed(1) : 0;
                        disciplinesWrapper.innerHTML += `<div class="breakdown-row discipline-row"><span>${discipline.name}</span><span class="d-right">${formatTime(discSeconds)}</span><span class="d-right">${discPercentage}%</span></div>`;
                    }
                }
                tableBody.appendChild(disciplinesWrapper);
            }
        }

        function toggleCycleDetails(element) { element.classList.toggle('expanded'); }

        function formatTime(totalSeconds) {
            totalSeconds = Math.round(totalSeconds || 0);
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }
        
        window.addEventListener('load', handleAuth);
    </script>
</body>
</html>
