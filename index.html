<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CareerPath | Projeto de Estudos</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litepicker/dist/css/litepicker.css"/>

    <style>
        /* --- ESTILO BASE --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Poppins', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f8f9fa; color: #2c3e50; min-height: 100vh; }
        
        .app-container { display: flex; min-height: 100vh; }

        /* --- NAVEGAÇÃO LATERAL (NOVO LAYOUT) --- */
        .sidebar-nav {
            width: 260px;
            background-color: #0d253f;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            transition: width 0.3s ease;
            z-index: 1100; /* Acima do overlay do modal */
        }
        .sidebar-header {
            padding: 22px 25px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .sidebar-header .logo-icon {
            width: 38px;
            height: 38px;
            fill: #ff6f61;
        }
        .sidebar-header h1 {
            font-size: 1.5em;
            font-weight: 600;
            color: #fff;
        }
        .sidebar-menu {
            flex-grow: 1;
            list-style: none;
            margin-top: 20px;
        }
        .sidebar-menu li {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 16px 25px;
            margin: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
            color: #aeb8c2;
            font-weight: 500;
        }
        .sidebar-menu li .material-icons-outlined {
            font-size: 24px;
        }
        .sidebar-menu li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .sidebar-menu li.active {
            background-color: #ff6f61;
            color: #fff;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(255, 111, 97, 0.3);
        }
        .sidebar-footer {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .logout-button {
            display: flex;
            align-items: center;
            gap: 15px;
            background: none;
            border: none;
            color: #aeb8c2;
            font-size: 16px;
            font-family: 'Poppins', sans-serif;
            width: 100%;
            text-align: left;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        .logout-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        /* -- FIM DA NAVEGAÇÃO LATERAL -- */
        
        /* --- ÁREA DE CONTEÚDO PRINCIPAL --- */
        .main-content {
            margin-left: 260px; /* Largura da sidebar */
            width: calc(100% - 260px);
            padding: 30px;
            transition: margin-left 0.3s ease, width 0.3s ease;
        }

        .view { display: none; }
        .view.active { display: block; }
        
        /* --- TELAS DE TELA CHEIA (LOGIN, CARREGANDO) --- */
        .fullscreen-view { 
            text-align: center; 
            padding: 60px 20px; 
            background: white; 
            border-radius: 12px; 
            max-width: 550px; 
            margin: 60px auto; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); 
            border: 1px solid #e9ecef; 
        }
        .fullscreen-view h2 { margin-bottom: 15px; font-size: 1.8em; color: #003366; }
        .fullscreen-view p { margin-bottom: 30px; color: #6c757d; line-height: 1.6; }
        #login-button { display: inline-flex; align-items: center; gap: 15px; padding: 12px 28px; font-size: 16px; font-weight: 500; background: #4285F4; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        #login-button:hover { background-color: #357ae8; }
        #login-button svg { width: 20px; height: 20px; }

        /* --- ESTILOS DE CONTEÚDO PRINCIPAL --- */
        .content-wrapper, #cycle-selection-view { background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid #e9ecef; }
        .page-header { font-size: 2em; color: #003366; font-weight: 600; margin-bottom: 30px; display: flex; align-items: center; gap: 15px; }
        .page-header .material-icons-outlined { font-size: 1.2em; }

        /* --- BOTÕES E INPUTS --- */
        button { background-color: #0d253f; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: 500; font-family: 'Poppins', sans-serif; transition: transform 0.2s, box-shadow 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(13, 37, 63, 0.2); }
        button:disabled { background-color: #aeb8c2; opacity: 1; cursor: not-allowed; transform: none; box-shadow: none; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 12px; border: 1px solid #ced4da; border-radius: 8px; font-size: 16px; font-family: 'Poppins', sans-serif; transition: border-color 0.3s, box-shadow 0.3s; }
        input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: #ff6f61; box-shadow: 0 0 0 3px rgba(255, 111, 97, 0.2); }
        .remove-btn, button.secondary { background-color: #e9ecef; color: #495057; }
        .remove-btn:hover, button.secondary:hover { background-color: #dee2e6; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); }
        button.danger { background-color: #e74c3c; }
        button.danger:hover { box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3); }

        /* --- GRÁFICO E STATS --- */
        .chart-container { background-color: #fff; border: 1px solid #e9ecef; border-radius: 12px; padding: 20px; margin: 20px 0; display: flex; justify-content: center; position: relative; }
        #wheelChart text { fill: #6c757d; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background-color: #fff; border: 1px solid #e9ecef; color: #2c3e50; padding: 20px; border-radius: 12px; text-align: center; }
        .stat-number { font-size: 2em; font-weight: 600; color: #0d253f; margin-bottom: 5px; }
        .stat-label { font-size: 0.9em; color: #6c757d; }

        /* --- LISTA DE DISCIPLINAS --- */
        .discipline-list { margin: 20px 0; }
        .discipline-item { display: flex; align-items: center; gap: 15px; padding: 15px; margin: 10px 0; background: #fdfdff; border-radius: 10px; border: 1px solid #e9ecef; transition: all 0.3s; flex-wrap: wrap; border-left: 5px solid; }
        .discipline-item.completed { border-left-color: #28a745 !important; background-color: #f6fff8; }
        .discipline-name-group { flex: 1; display: flex; align-items: center; gap: 10px; font-weight: 500; min-width: 150px; }
        .edit-btn { background: none; border: none; color: #6c757d; cursor: pointer; padding: 4px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        .edit-btn:hover { background-color: #e9ecef; color: #0d253f; }
        .timer-btn { background-color: #28a745; font-size: 14px; padding: 10px 16px; }
        .timer-btn.stop { background-color: #ff6f61; }
        
        /* --- CALENDÁRIO --- */
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; }
        .calendar-nav-group { display: flex; align-items: center; gap: 10px; }
        .calendar-title { color: #0d253f; font-weight: 600; text-align: center; flex-grow: 1; }
        .view-toggles { display: flex; }
        .view-toggles button { font-size: 14px; padding: 6px 12px; border-radius: 6px; background-color: #e9ecef; color: #495057; border: 1px solid #dee2e6; }
        .view-toggles button.active { background-color: #0d253f; color: white; border-color: #0d253f; }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day-header { text-align: center; font-weight: 600; color: #6c757d; font-size: 0.9em; padding-bottom: 10px; }
        .calendar-day { aspect-ratio: 1; border: 1px solid transparent; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; position: relative; font-size: 14px; }
        .calendar-day:hover { background-color: #f0f3f5; }
        .calendar-day.today { border-color: #ff6f61; }
        .calendar-day.selected { background-color: #0d253f; color: white; }
        .calendar-day.has-studies { font-weight: 600; }
        .calendar-day.has-studies::after { content: ''; position: absolute; bottom: 6px; left: 50%; transform: translateX(-50%); width: 5px; height: 5px; background-color: #0d253f; border-radius: 50%; }
        .calendar-day.selected.has-studies::after { background-color: #ff6f61; }
        .calendar-nav { background-color: #0d253f; }
        .calendar-summary { text-align: center; font-size: 1.1em; font-weight: 500; color: #0d253f; background-color: #e9f0f5; padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .study-history { border-top: 1px solid #dee2e6; margin-top: 20px; padding-top: 20px; }
        .daily-total { font-size: 1.1em; font-weight: 600; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #e9ecef; }
        .study-history-item { padding: 8px; margin-top: 5px; background: #fdfdff; border-left: 3px solid #0d253f; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
        .history-delete-btn { background: #e74c3c; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px; line-height: 24px; text-align: center; padding: 0; }

        /* --- TELA DE RELATÓRIOS --- */
        .reports-filter-bar { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 20px; margin-bottom: 30px; }
        .filter-group { display: flex; flex-direction: column; gap: 5px; }
        .filter-group label { font-size: 0.9em; font-weight: 500; color: #495057; }
        #report-date-input { width: 260px; text-align: center; cursor: pointer; }
        #report-cycle-filter { width: 220px; }

        .reports-kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .kpi-card { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; }
        .kpi-card .kpi-label { font-size: 1em; color: #6c757d; margin-bottom: 8px; }
        .kpi-card .kpi-value { font-size: 1.8em; font-weight: 600; color: #0d253f; }
        .reports-charts-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; margin-bottom: 30px; align-items: start; }
        .chart-wrapper { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; position: relative; height: 400px; }
        .chart-wrapper h3 { margin-bottom: 20px; font-weight: 500; color: #343a40; }
        .reports-breakdown { background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; }
        .breakdown-header { display: grid; grid-template-columns: 1fr 100px 100px; padding: 0 15px 10px 15px; border-bottom: 2px solid #dee2e6; font-weight: 600; color: #6c757d; font-size: 0.9em; }
        .breakdown-header .d-right, .breakdown-row .d-right { text-align: right; }
        .breakdown-row { display: grid; grid-template-columns: 1fr 100px 100px; align-items: center; padding: 12px 15px; border-bottom: 1px solid #f1f3f5; }
        .breakdown-row.cycle-row { font-weight: 500; cursor: pointer; }
        .breakdown-row.cycle-row:hover { background-color: #f8f9fa; }
        .cycle-name-cell { display: flex; align-items: center; gap: 8px; }
        .cycle-color-dot { width: 10px; height: 10px; border-radius: 50%; }
        .toggle-arrow { transition: transform 0.2s; }
        .cycle-row.expanded .toggle-arrow { transform: rotate(90deg); }
        .discipline-rows-wrapper { display: none; }
        .cycle-row.expanded + .discipline-rows-wrapper { display: block; }
        .discipline-row { padding-left: 40px; background-color: #fbfdff; }


        /* --- MODAIS E OUTROS --- */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1000; justify-content: center; align-items: center; padding: 20px; }
        .modal-content { background: white; padding: 30px 40px; border-radius: 12px; text-align: center; max-width: 500px; width: 100%; box-shadow: 0 5px 25px rgba(0,0,0,0.2); animation: modal-appear 0.3s ease-out; }
        @keyframes modal-appear { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .modal-content h3 { color: #0d253f; margin-bottom: 15px; font-size: 1.6em; }
        .modal-content p { margin-bottom: 30px; color: #6c757d; font-size: 1.1em; line-height: 1.6; }
        .modal-buttons { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
        .trophy-icon { width: 60px; height: 60px; margin: 0 auto 20px auto; fill: #ffc107; }
        .form-group-modal { margin-bottom: 15px; text-align: left; }
        .form-group-modal label { display: block; margin-bottom: 5px; font-weight: 500; }
        #cycle-selection-view { text-align: center; padding: 40px 20px; max-width: 600px; margin: 40px auto; }
        .add-discipline-form { background: #f8f9fa; border: 1px solid #e9ecef; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .form-title { font-size: 1.2em; font-weight: 600; margin-bottom: 15px; color: #0d253f; }
        .input-row { display: flex; gap: 10px; align-items: flex-end; margin-bottom: 10px; }
        .input-row .input-group { flex-grow: 1; }
        .time-input-container { display: flex; gap: 10px; align-items: flex-end; }
        .time-input-group { display: flex; flex-direction: column; align-items: center; }
        .time-input-group label { font-size: 0.8em; color: #666; margin-bottom: 4px; }
        .time-input-group input { width: 70px; text-align: center; }
        .time-input-separator { font-size: 1.5em; color: #999; padding-bottom: 10px; }

        /* Estilos para seleção de cor do Projeto */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        .color-box {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }
        .color-box:hover {
            transform: translateY(-2px);
            border-color: #0d253f;
        }
        .color-box.selected {
            border-color: #0d253f;
            box-shadow: 0 0 0 3px rgba(13, 37, 63, 0.3);
            transform: scale(1.05);
        }
        .existing-cycles-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            padding: 15px;
            background-color: #f0f3f5;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .existing-cycle-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: #e9ecef;
            font-size: 0.9em;
        }

        /* Estilos para a tela de Tags */
        #allTagsList {
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            max-height: 200px;
            overflow-y: auto;
            align-items: flex-start; /* Alinha os itens ao topo */
        }
        .tag-item {
            display: inline-block;
            background-color: #e9ecef;
            color: #495057;
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            white-space: nowrap; /* Evita quebras de linha dentro da tag */
        }
        .tag-item:hover {
            background-color: #dee2e6;
            color: #0d253f;
        }
        .tag-item.active {
            background-color: #0d253f;
            color: white;
        }

        .tag-results .breakdown-header {
            grid-template-columns: 2fr 100px; /* Ajuste para assunto/disciplina/projeto e duração */
        }
        .tag-results .tag-study-item {
            display: grid;
            grid-template-columns: 2fr 100px;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #f1f3f5;
            word-break: break-word; /* Permite quebras de palavras longas */
        }
        .tag-study-item .study-details {
            display: flex;
            flex-direction: column;
        }
        .tag-study-item .study-details .main-info {
            font-weight: 500;
            color: #2c3e50;
        }
        .tag-study-item .study-details .sub-info {
            font-size: 0.85em;
            color: #6c757d;
        }

        /* Estilos para Modais Específicos */
        #addTimeToDayModal .modal-content {
            max-width: 400px; /* Reduz a largura máxima do modal */
            padding: 20px;   /* Reduz o padding geral do modal */
            overflow-y: auto; /* Permite scroll se o conteúdo for muito alto */
            max-height: 90vh; /* Limita a altura máxima para não estourar a tela */
        }

        /* Ajustes para os grupos de input de tempo dentro DOS MODAIS GERALMENTE */
        .modal-content .time-input-container {
            flex-wrap: wrap; 
            justify-content: center;
            gap: 3px; /* Reduz ainda mais o espaço entre os campos de tempo */
            margin-bottom: 15px; /* Adiciona um espaço inferior */
        }

        .modal-content .time-input-group {
            flex: 1 1 55px; /* Permite flexibilidade, com base de 55px */
            max-width: 70px; /* Limita a largura máxima para cada HH/MM/SS */
            min-width: 50px; /* Garante um tamanho mínimo menor */
            align-items: center; /* Centraliza os itens dentro do grupo */
        }

        .modal-content .time-input-group label {
            font-size: 0.7em; /* Reduz um pouco mais a fonte dos labels HH/MM/SS */
            margin-bottom: 2px;
            white-space: nowrap; /* Impede que o label quebre linha */
        }

        .modal-content .time-input-group input {
            width: 100%; 
            padding: 5px; /* Reduz o padding para economizar espaço */
            font-size: 12px; /* Diminui a fonte do texto dentro do input */
            height: 30px; /* Altura fixa ligeiramente menor para inputs de tempo */
        }

        .modal-content .time-input-separator {
            font-size: 0.9em; /* Diminui o tamanho do separador ':' */
            padding-bottom: 0;
            margin-top: 10px; 
        }

        /* Ajuste para garantir que os selects (Projeto/Disciplina) não sejam muito largos */
        .form-group-modal select {
            width: 100%;
            padding: 8px 12px; /* Reduz o padding dos selects */
            font-size: 14px; /* Reduz a fonte dos selects */
        }

        /* Ajuste para os textareas e inputs de texto */
        .form-group-modal textarea,
        .form-group-modal input[type="text"] {
            padding: 8px 10px; /* Reduz o padding */
            font-size: 14px; /* Reduz a fonte */
        }

        /* Regra específica para o modal AddTimeToDay, para garantir a centralização dos botões */
        #addTimeToDayModal .modal-buttons {
            margin-top: 20px; /* Garante espaço acima dos botões */
            gap: 10px; /* Reduz o espaço entre os botões */
        }
        #addTimeToDayModal .modal-buttons button {
            padding: 10px 15px; /* Reduz o padding dos botões */
            font-size: 14px; /* Reduz a fonte dos botões */
        }

        /* Media query para telas médias (já existia, só ajustar os valores se achar necessário) */
        @media (max-width: 1440px) {
            #addTimeToDayModal .modal-content {
                max-width: 380px; /* Pode tentar reduzir para 380px ou 360px */
                padding: 18px 20px; 
            }
        }

        /* Media query para telas menores (smartphones, para ter certeza) */
        @media (max-width: 768px) { /* Use 768px para atingir tablets e smartphones em landscape */
            #addTimeToDayModal .modal-content {
                max-width: 95%; /* Ocupa a maior parte da largura */
                padding: 15px; /* Padding mínimo */
            }
            .modal-content .time-input-group {
                flex: 1 1 60px; /* Mais flexibilidade */
                min-width: 55px;
            }
            .modal-content .time-input-separator {
                display: flex; /* Mantém o ':' mas pode ser removido em 480px se ainda apertar */
            }
        }

        @media (max-width: 480px) {
            #addTimeToDayModal .modal-content {
                max-width: 98%; 
                padding: 10px; /* Padding ainda menor */
            }
            .modal-content .time-input-group {
                flex: 1 1 auto; /* Permite que ocupe o espaço que precisar, mas com min-width */
                min-width: 45px; /* Min-width para cada campo HH/MM/SS */
                max-width: none; /* Não tem max-width aqui, para encolher */
            }
            .modal-content .time-input-separator {
                display: none; /* Esconde o ":" em telas muito pequenas para economizar espaço */
            }
            #addTimeToDayModal .modal-buttons {
                flex-direction: column; /* Botões empilhados em telas muito pequenas */
            }
        }

        /* Garante que os inputs dentro dos modais de tempo não sejam muito largos */
        .modal-content input[type="text"],
        .modal-content input[type="number"],
        .modal-content textarea,
        .modal-content select {
            width: 100%; /* Garante que eles ocupem a largura disponível */
            max-width: 100%; /* Impede que eles se estiquem além do contêiner */
            box-sizing: border-box; /* Inclui padding e borda na largura total */
        }

        /* Ajustes para os grupos de input de tempo dentro DOS MODAIS GERALMENTE */
        .modal-content .time-input-container {
            /* Permite que os itens quebrem para a próxima linha se não houver espaço */
            flex-wrap: wrap; 
            justify-content: center; /* Centraliza os grupos quando quebram */
            gap: 5px; /* Reduz o espaço entre os campos de tempo */
        }

        .modal-content .time-input-group {
            /* Permite que cada grupo de input de tempo tenha uma largura flexível */
            flex: 1 1 70px; /* Cresce e encolhe, com base de 70px */
            max-width: 90px; /* Limita a largura máxima para cada HH/MM/SS */
            min-width: 60px; /* Garante um tamanho mínimo */
        }

        .modal-content .time-input-group label {
            font-size: 0.75em; /* Reduz um pouco mais a fonte dos labels HH/MM/SS */
            margin-bottom: 2px;
        }

        .modal-content .time-input-group input {
            width: 100%; /* Garante que o input preencha o grupo */
            padding: 6px; /* Reduz o padding para economizar espaço */
            font-size: 13px; /* Diminui a fonte do texto dentro do input */
            height: 32px; /* Altura fixa para inputs de tempo */
        }

        .modal-content .time-input-separator {
            font-size: 1em; /* Diminui o tamanho do separador ':' */
            padding-bottom: 0; /* Remove padding que pode afetar alinhamento */
            display: flex; /* Garante alinhamento vertical */
            align-items: center; /* Alinha o ':' no centro vertical */
            margin-top: 10px; /* Ajusta a posição vertical */
        }

        /* Regra específica para o modal AddTimeToDay, para garantir a centralização dos botões e campos */
        #addTimeToDayModal .modal-content .modal-buttons,
        #addTimeToDayModal .modal-content .form-group-modal {
            max-width: 100%; /* Garante que não forcem largura extra */
            margin-left: auto;
            margin-right: auto;
        }

        /* Media query para telas médias, entre 1024px e 1440px, que podem estar cortando */
        @media (max-width: 1440px) {
            #addTimeToDayModal .modal-content {
                max-width: 420px; /* Reduz a largura máxima para telas médias */
                padding: 20px 25px; /* Reduz o padding um pouco mais */
            }
        }

        /* Media query para telas menores (smartphones, por exemplo), se as anteriores não forem suficientes */
        @media (max-width: 480px) {
            #addTimeToDayModal .modal-content {
                max-width: 98%; /* Quase 100% da largura em telas muito pequenas */
                padding: 15px; /* Padding mínimo */
            }
            .modal-content .time-input-container {
                flex-wrap: wrap; /* Garante a quebra */
            }
            .modal-content .time-input-group {
                flex: 1 1 80px; /* Permite mais espaço para cada input se necessário */
                max-width: none; /* Remove limite de max-width aqui */
            }
            .modal-content .time-input-separator {
                display: none; /* Esconde o ":" em telas muito pequenas para economizar espaço */
            }
        }


        /* Media query para telas ainda menores (celulares, por exemplo) */
        @media (max-width: 600px) {
            #addTimeToDayModal .modal-content {
                max-width: 95%; /* Ocupa quase toda a largura em telas muito pequenas */
                margin: 20px auto; /* Centraliza verticalmente */
                padding: 20px; /* Reduz ainda mais o padding */
            }

            .modal-content .time-input-container {
                flex-wrap: wrap; /* Permite quebrar em várias linhas se não couber */
                justify-content: center;
            }

            .modal-content .time-input-group {
                width: calc(33% - 10px); /* Tenta manter 3 colunas em telas pequenas */
                min-width: 80px; /* Garante um tamanho mínimo */
            }
             .modal-content .time-input-group input {
                width: 100%;
                max-width: none;
            }
            .modal-content .time-input-separator {
                display: none; /* Esconde o ":" quando quebra a linha */
            }
        }

        @media (max-width: 992px) {
            .sidebar-nav { width: 70px; }
            .sidebar-nav .sidebar-header h1, .sidebar-nav .menu-text, .sidebar-nav .logout-text { display: none; }
            .sidebar-nav .sidebar-header { justify-content: center; padding: 20px 0;}
            .main-content { margin-left: 70px; width: calc(100% - 70px); }
            .sidebar-menu li { justify-content: center; }
            .sidebar-footer .logout-button { justify-content: center; }
        }

        @media (max-width: 768px) {
            .reports-charts-grid { grid-template-columns: 1fr; }
            .breakdown-header, .breakdown-row { grid-template-columns: 1fr 80px 70px; font-size: 0.9em; }
            .main-content { padding: 15px; }
        }

        @media (max-width: 600px) {
            .sidebar-nav { display: none; } /* Esconde a sidebar em telas muito pequenas */
            .main-content { margin-left: 0; width: 100%; } /* Conteúdo ocupa toda a tela */
            /* Futuramente, pode-se adicionar um botão 'hamburger' para mostrar/esconder a sidebar */
            .calendar-header { flex-direction: column; gap: 15px; }
            body { padding: 5px; }
            .main-content { padding: 10px; }
            .content-wrapper, #cycle-selection-view { padding: 15px; }
            .page-header { font-size: 1.5em; }
            .add-discipline-form .input-row { flex-wrap: wrap; gap: 15px; }
            .add-discipline-form .input-group { width: 100%; min-width: 100%; }
            .add-discipline-form .time-input-container { flex-grow: 1; }
            .add-discipline-form button { flex-grow: 1; }
            .stats { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
        }
    </style>
</head>
<body>

    <div id="app-wrapper">
        
        <aside class="sidebar-nav" style="display: none;">
            <div class="sidebar-header">
                <svg class="logo-icon" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256 256-114.6 256-256S399.4 0 256 0zm0 464C141.1 464 48 370.9 48 256S141.1 48 256 48s208 93.1 208 208-93.1 208-208 208zm-62.5-133.3l105.3-43.9 43.9-105.3-105.3 43.9-43.9 105.3z"/></svg>
                <h1 class="menu-text">CareerPath</h1>
            </div>
            <ul class="sidebar-menu">
                <li onclick="switchView('current')" data-view="current">
                    <span class="material-icons-outlined">timer</span>
                    <span class="menu-text">Timer</span>
                </li>
                <li onclick="switchView('reports')" data-view="reports">
                    <span class="material-icons-outlined">bar_chart</span>
                    <span class="menu-text">Relatórios</span>
                </li>
                <li onclick="switchView('calendar')" data-view="calendar">
                    <span class="material-icons-outlined">calendar_today</span>
                    <span class="menu-text">Calendário</span>
                </li>
                <li onclick="switchView('tags')" data-view="tags">
                    <span class="material-icons-outlined">label</span>
                    <span class="menu-text">Tags</span>
                </li>
            </ul>
            <div class="sidebar-footer">
                <button class="logout-button" onclick="signOutUser()">
                    <span class="material-icons-outlined">exit_to_app</span>
                    <span class="logout-text">Sair</span>
                </button>
            </div>
        </aside>

        <main class="main-content">
            <div id="loading-view" class="view active fullscreen-view">
                <h2>Carregando...</h2>
                <p>Verificando sua conta CareerPath.</p>
            </div>

            <div id="login-view" class="view fullscreen-view">
                <h2>Bem-vindo ao seu Controle de Estudos</h2>
                <p>Faça login com sua conta Google para salvar e sincronizar seus históricos de estudo na plataforma CareerPath.</p>
                <button id="login-button" onclick="signInWithGoogle()">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="24px" height="24px"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24s8.955,20,20,20s20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"/><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"/><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.223,0-9.651-3.358-11.303-8H6.306C9.656,39.663,16.318,44,24,44z"/><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C39.901,35.636,44,30.138,44,24C44,22.659,43.862,21.35,43.611,20.083z"/></svg>
                    <span>Entrar com Google</span>
                </button>
            </div>

            <div id="cycle-selection-view" class="view content-wrapper">
                <h2>Selecione ou Crie um Projeto</h2>
                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label for="existingCycleSelector" style="display: block; margin-bottom: 8px; font-weight: 500;">Escolha um Projeto existente</label>
                    <select id="existingCycleSelector"></select>
                </div>
                <button onclick="loadSelectedCycle()">Carregar Projeto</button>
                <div style="margin: 25px 0; font-weight: bold; color: #999;">OU</div>
                
                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label for="newCycleNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Crie um novo Projeto</label>
                    <input type="text" id="newCycleNameInput" placeholder="Ex: Trilha Front-End...">
                </div>

                <div class="form-group" style="margin-bottom: 20px; text-align: left;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cores de Projetos existentes:</label>
                    <div id="existingCyclesDisplay" class="existing-cycles-display">
                        </div>
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">Escolha uma cor para o novo Projeto:</label>
                    <div id="cycleColorPalette" class="color-palette">
                        </div>
                </div>
                <button onclick="createNewCycle()">Criar e Iniciar</button>
                <button class="danger" onclick="signOutUser()" style="margin-top: 30px;">Sair</button>
            </div>

            <div id="current-view" class="view">
                <header class="page-header">
                    <span class="material-icons-outlined">track_changes</span>
                    <span id="cycleTitleText"></span>
                </header>
                <div class="content-wrapper">
                    <div id="main-content">
                        <div class="stats">
                            <div class="stat-card"><div class="stat-number" id="cycleCompletions">0</div><div class="stat-label">Vezes Concluído</div></div>
                            <div class="stat-card"><div class="stat-number" id="totalDisciplines">0</div><div class="stat-label">Disciplinas</div></div>
                            <div class="stat-card"><div class="stat-number" id="totalHours">0h</div><div class="stat-label">Horas Hoje</div></div>
                        </div>
                        
                        <div class="add-discipline-form">
                            <div class="form-title">Adicionar Nova Disciplina</div>
                            <div class="input-row">
                                <div class="input-group"><input type="text" id="disciplineInput" placeholder="Nome da disciplina..."></div>
                                <div class="time-input-container">
                                    <div class="time-input-group">
                                        <label for="hoursInput">Horas</label>
                                        <input type="number" id="hoursInput" min="0" placeholder="HH" value="1">
                                    </div>
                                    <span class="time-input-separator">:</span>
                                    <div class="time-input-group">
                                        <label for="minutesInput">Minutos</label>
                                        <input type="number" id="minutesInput" min="0" max="59" step="5" placeholder="MM" value="0">
                                    </div>
                                </div>
                                <button onclick="addDiscipline()">Adicionar</button>
                            </div>
                        </div>

                        <div class="chart-container" id="chartContainer"><svg id="wheelChart" width="400" height="400" viewBox="0 0 400 400"></svg></div>
                        <div class="discipline-list" id="disciplinesList"></div>

                        <div id="mainControls" style="display:flex; flex-wrap: wrap; gap:10px; margin-top:30px; justify-content:center;">
                            <button class="secondary" onclick="returnToCycleSelection()">Trocar de Projeto</button>
                            <button class="secondary" onclick="manuallyEndCycle()">Encerrar Projeto</button>
                            <button class="danger" onclick="deleteCurrentCycle()">Apagar Projeto Atual</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="calendar-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">calendar_today</span> Calendário de Estudos</header>
                <div class="content-wrapper">
                    <div class="calendar-header">
                        <div class="calendar-nav-group">
                            <button class="calendar-nav" onclick="navigateCalendar(-1)">❮</button>
                            <h2 id="calendarTitle" class="calendar-title"></h2>
                            <button class="calendar-nav" onclick="navigateCalendar(1)">❯</button>
                        </div>
                        <div class="view-toggles">
                            <button id="view-toggle-month" class="active" onclick="setCalendarView('month')">Mês</button>
                            <button id="view-toggle-week" onclick="setCalendarView('week')">Semana</button>
                        </div>
                    </div>
                    <div id="calendar-summary" class="calendar-summary"></div>
                    <div class="calendar-grid">
                        <div class="calendar-day-header">Dom</div><div class="calendar-day-header">Seg</div><div class="calendar-day-header">Ter</div><div class="calendar-day-header">Qua</div><div class="calendar-day-header">Qui</div><div class="calendar-day-header">Sex</div><div class="calendar-day-header">Sáb</div>
                    </div>
                    <div class="calendar-grid" id="calendarGrid"></div>
                    <div id="selectedDateInfo" class="study-history" style="display: none;"></div>
                </div>
            </div>

            <div id="reports-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">bar_chart</span> Relatórios</header>
                <div class="content-wrapper">
                    <div class="reports-filter-bar">
                        <div class="filter-group">
                            <label for="report-date-input">Período</label>
                            <input type="text" id="report-date-input" readonly>
                        </div>
                        <div class="filter-group">
                            <label for="report-cycle-filter">Filtrar por Projeto</label>
                            <select id="report-cycle-filter" onchange="renderReportsView()"></select>
                        </div>
                    </div>

                    <div class="reports-kpi-grid">
                        <div class="kpi-card">
                            <div class="kpi-label">Duração Total</div>
                            <div class="kpi-value" id="report-total-hours">00:00:00</div>
                        </div>
                        <div class="kpi-card">
                            <div class="kpi-label">Média Diária</div>
                            <div class="kpi-value" id="report-daily-average">00:00:00</div>
                        </div>
                    </div>

                    <div class="reports-charts-grid">
                        <div class="chart-wrapper">
                            <h3>Duração por Dia</h3>
                            <canvas id="durationBarChart"></canvas>
                        </div>
                        <div class="chart-wrapper">
                            <h3>Distribuição por Projeto</h3>
                            <canvas id="distributionDonutChart"></canvas>
                        </div>
                    </div>

                    <div class="reports-breakdown">
                        <div class="breakdown-header">
                            <span>Projeto / DISCIPLINA</span>
                            <span class="d-right">DURAÇÃO</span>
                            <span class="d-right">%</span>
                        </div>
                        <div id="breakdown-table-body"></div>
                    </div>
                </div>
            </div>
            <div id="tags-view" class="view">
                <header class="page-header"><span class="material-icons-outlined">label</span> Buscar por Tags</header>
                <div class="content-wrapper">
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label for="tagSearchInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Pesquisar Tags (Ex: #python)</label>
                        <input type="text" id="tagSearchInput" placeholder="Digite uma tag ou parte dela..." onkeyup="filterTagsAndStudies()">
                        <div id="allTagsList" style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px;">
                            </div>
                    </div>
                    
                    <div class="tag-results" id="tagSearchResults">
                        <h4 style="margin-bottom: 15px; color: #0d253f;">Resultados da Busca</h4>
                        <div class="breakdown-header">
                            <span>Assunto / Disciplina / Projeto</span>
                            <span class="d-right">DURAÇÃO</span>
                        </div>
                        <div id="tagResultsBody">
                            <p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado para exibir. Use a busca acima ou clique em uma tag.</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <div id="completionModal" class="modal-overlay"> <div class="modal-content"> <h3>Projeto Concluído!</h3> <p>Parabéns! Você atingiu a meta de todas as disciplinas. O que deseja fazer agora?</p> <div class="modal-buttons"> <button class="secondary" onclick="handleContinueCycle()">Continuar Neste Projeto</button> <button onclick="handleStartNewCycle()">Iniciar Novo Projeto</button> </div> </div> </div>
    <div id="celebrationModal" class="modal-overlay"> <div class="modal-content"> <svg class="trophy-icon" viewBox="0 0 24 24"><path d="M20.2,4H22L19,2H5L2,4h1.8C4.4,4.8,5,5.9,5,7c0,1.5-1.2,2.7-2.7,2.9C2.1,10,2,10.1,2,10.3V12h1v9H2v1h20v-1h-1v-9h1v-1.7 c0-0.2-0.1-0.3-0.3-0.4C21.2,9.7,20,8.5,20,7C20,5.9,20.6,4.8,21.2,4H20.2z M4,12h2.1c0.5-0.7,1.2-1.3,2-1.7V12H4z M15.9,10.3 c0.8,0.4,1.5,1,2,1.7H20V12h-4.1V10.3z M12,6c1.1,0,2,0.9,2,2s-0.9,2-2,2s-2-0.9-2-2S10.9,6,12,6z"/></svg> <h3>Missão Cumprida!</h3> <p>Você é incrível! O Projeto foi concluído com sucesso e contabilizado. Pronto para o próximo desafio?</p> <div class="modal-buttons"> <button onclick="hideCelebrationModal()">Fechar</button> </div> </div> </div>
    <div id="alertModal" class="modal-overlay"> <div class="modal-content"> <h3 id="alertModalTitle">Atenção</h3> <p id="alertModalMessage"></p> <div class="modal-buttons"> <button onclick="hideAlertModal()">OK</button> </div> </div> </div>
    <div id="confirmModal" class="modal-overlay"> <div class="modal-content"> <h3 id="confirmModalTitle">Confirmar Ação</h3> <p id="confirmModalMessage"></p> <div class="modal-buttons"> <button class="secondary" onclick="hideConfirmModal()">Cancelar</button> <button class="danger" onclick="handleConfirmAction()">Confirmar</button> </div> </div> </div>
    <div id="editDisciplineModal" class="modal-overlay"> <div class="modal-content"> <h3>Editar Disciplina</h3> <input type="hidden" id="editDisciplineId"> <div class="form-group-modal"> <label for="editDisciplineName">Nome da Disciplina</label> <input type="text" id="editDisciplineName"> </div> <div class="form-group-modal"> <label>Meta de Tempo</label> <div class="time-input-container" style="justify-content: center;"> <div class="time-input-group"> <label for="editHoursInput">Horas</label> <input type="number" id="editHoursInput" min="0" placeholder="HH"> </div> <span class="time-input-separator">:</span> <div class="time-input-group"> <label for="editMinutesInput">Minutos</label> <input type="number" id="editMinutesInput" min="0" max="59" step="5" placeholder="MM"> </div> </div> </div> <div class="modal-buttons"> <button class="secondary" onclick="hideEditModal()">Cancelar</button> <button onclick="saveDisciplineChanges()">Salvar Alterações</button> </div> </div> </div>

<div id="addTimeModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Tempo Manualmente</h3>
            <input type="hidden" id="addTimeDisciplineId">
            <div class="form-group-modal">
                <label>Tempo a Adicionar</label>
                <div class="time-input-container" style="justify-content: center;">
                    <div class="time-input-group">
                        <label for="addTimeHoursInput">Horas</label>
                        <input type="number" id="addTimeHoursInput" min="0" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeMinutesInput">Minutos</label>
                        <input type="number" id="addTimeMinutesInput" min="0" max="59" step="5" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeSecondsInput">Segundos</label>
                        <input type="number" id="addTimeSecondsInput" min="0" max="59" step="1" value="0">
                    </div>
                </div>
            </div>
            <div class="form-group-modal">
                <label for="addTimeSubjectInput">Assunto (Opcional)</label>
                <input type="text" id="addTimeSubjectInput" placeholder="Ex: Métodos em JS" list="subjectRecommendations">
            </div>

            <div class="form-group-modal">
                <label for="addTimeTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="addTimeTagsInput" placeholder="Ex: #javascript, #frontend">
            </div>

            <div class="form-group-modal">
                <label for="addTimeStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="addTimeStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="hideAddTimeModal()">Cancelar</button>
                <button onclick="saveAddedTime()">Adicionar</button>
            </div>
        </div>
    </div>


<div id="addTimeToDayModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Adicionar Tempo ao Dia</h3>
            <p>Adicione tempo de estudo para a data selecionada: <strong id="addTimeToDayModalDate"></strong></p>
            <input type="hidden" id="addTimeToDaySelectedDate">

            <div class="form-group-modal">
                <label for="addTimeToDayCycleSelect">Projeto de Estudo</label>
                <select id="addTimeToDayCycleSelect" onchange="populateAddTimeToDayDisciplines()"></select>
            </div>

            <div class="form-group-modal">
                <label for="addTimeToDayDisciplineSelect">Disciplina</label>
                <select id="addTimeToDayDisciplineSelect"></select>
            </div>
            
            <div class="form-group-modal">
                <label>Tempo Estudado</label>
                <div class="time-input-container" style="justify-content: center;">
                    <div class="time-input-group">
                        <label for="addTimeToDayHoursInput">Horas</label>
                        <input type="number" id="addTimeToDayHoursInput" min="0" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeToDayMinutesInput">Minutos</label>
                        <input type="number" id="addTimeToDayMinutesInput" min="0" max="59" step="5" value="0">
                    </div>
                    <span class="time-input-separator">:</span>
                    <div class="time-input-group">
                        <label for="addTimeToDaySecondsInput">Segundos</label>
                        <input type="number" id="addTimeToDaySecondsInput" min="0" max="59" step="1" value="0">
                    </div>
                </div>
            </div>
            <div class="form-group-modal">
                <label for="addTimeToDaySubjectInput">Assunto (Opcional)</label>
                <input type="text" id="addTimeToDaySubjectInput" placeholder="Ex: Estruturas de Dados" list="subjectRecommendations">
            </div>

            <div class="form-group-modal">
                <label for="addTimeToDayTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="addTimeToDayTagsInput" placeholder="Ex: #algoritmos, #computacao">
            </div>

            <div class="form-group-modal">
                <label for="addTimeToDayStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="addTimeToDayStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="secondary" onclick="hideAddTimeToDayModal()">Cancelar</button>
                <button onclick="saveAddTimeToDayEntry()">Adicionar Tempo</button>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="position: fixed; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px; pointer-events: none; display: none; z-index: 1000; white-space: nowrap; transition: opacity 0.2s;"></div>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

    <script src="https://cdn.jsdelivr.net/npm/litepicker/dist/litepicker.js"></script>

<div id="startTimerModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Iniciar Estudo: <span id="startTimerDisciplineName"></span></h3>
            <input type="hidden" id="startTimerDisciplineId">

            <div class="form-group-modal">
                <label for="startTimerSubjectInput">Assunto (Opcional)</label>
                <input type="text" id="startTimerSubjectInput" placeholder="Ex: Funções em Python" list="subjectRecommendations">
                <datalist id="subjectRecommendations"></datalist>
            </div>

            <div class="form-group-modal">
                <label for="startTimerTagsInput">Tags (Opcional, separe por vírgulas ou espaços)</label>
                <input type="text" id="startTimerTagsInput" placeholder="Ex: #python, #logica">
            </div>

           
            <div class="modal-buttons">
                <button class="secondary" onclick="hideStartTimerModal()">Cancelar</button>
                <button onclick="confirmStartTimer()">Iniciar Timer</button>
            </div>
        </div>
    </div>

    <div id="stopTimerModal" class="modal-overlay">
        <div class="modal-content">
            <h3>Pausar Estudo: <span id="stopTimerDisciplineName"></span></h3>
            <input type="hidden" id="stopTimerDisciplineId">
            <input type="hidden" id="stopTimerStudyRecordIndex">
            <input type="hidden" id="stopTimerStudyDate">
            <input type="hidden" id="stopTimerStudyCycleId">

            <div class="form-group-modal">
                <label for="stopTimerStopPoint">Ponto de parada do estudo (Opcional, até 500 caracteres)</label>
                <textarea id="stopTimerStopPoint" rows="4" maxlength="500" placeholder="Onde você parou?"></textarea>
            </div>
            
            <div class="modal-buttons">
                <button class="secondary" onclick="cancelStopTimer()">Cancelar</button>
                <button onclick="confirmStopTimer()">Pausar</button>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDU50I5YKjP-pH8NfCuc59N5_U0rzbeac4", 
            authDomain: "ciclo-de-estudo-elias.firebaseapp.com", 
            projectId: "ciclo-de-estudo-elias", 
            storageBucket: "ciclo-de-estudo-elias.appspot.com",
            messagingSenderId: "1065929930079",
            appId: "1:1065929930079:web:28eaffabc8daeb7ff732ea",
            measurementId: "G-KX8EJZD2CQ"
        };
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const provider = new firebase.auth.GoogleAuthProvider();

        
        // Cor reservada para relatórios (não pode ser usada para disciplinas)
        const REPORT_RESERVED_COLOR = '#0D253F';

        // Paleta de cores para os Projetos de estudo (vibrantes e distintas)
        const CYCLE_COLOR_PALETTE = [
            '#E6194B',  // Vermelho Vivo
            '#F58231',  // Laranja Forte
            '#FFE119',  // Amarelo Intenso
            '#BFEF45',  // Verde Limão
            '#3CB44B',  // Verde Floresta
            '#42D4F4',  // Verde Água
            '#4363D8',  // Azul Céu
            '#000075',  // Azul Marinho
            '#911EB4',  // Roxo Púrpura
            '#F032E6',  // Magenta
            '#FABED4',  // Rosa Choque
            '#A52A2A',  // Marrom Terra
            '#FFD8B1',  // Bege Claro
            '#808080',  // Cinza Carvão
            '#469990',  // Azul Petróleo
            '#46F0F0',  // Turquesa Vibrante
            '#0066FF',  // Azul Royal
            '#FF6700',  // Laranja Neon
            '#00FF87',  // Verde Neon
            '#FFD700',  // Amarelo Ouro
            '#FF1493',  // Rosa Neon
            '#8A2BE2'   // Violeta Elétrico
        ];

        
        // Gerador de cores aleatórias que evita a cor reservada (para disciplinas)
        class ColorGenerator {
            constructor() {
                this.usedColors = new Set();
                this.minDistance = 100; // Distância mínima entre cores no espaço RGB
            }

            // Converte HSL para RGB
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }

            // Calcula distância entre duas cores no espaço RGB
            colorDistance(rgb1, rgb2) {
                return Math.sqrt(
                    Math.pow(rgb1[0] - rgb2[0], 2) +
                    Math.pow(rgb1[1] - rgb2[1], 2) +
                    Math.pow(rgb1[2] - rgb2[2], 2)
                );
            }

            // Converte RGB para hex
            rgbToHex(r, g, b) {
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            // Gera cor vibrante usando HSL
            generateVibrantColor(reservedColor = null) {
                let attempts = 0;
                const maxAttempts = 100;

                while (attempts < maxAttempts) {
                    // HSL para cores mais vibrantes
                    const hue = Math.floor(Math.random() * 360); // 0-359
                    const saturation = Math.floor(Math.random() * 30) + 70; // 70-100% (alta saturação)
                    const lightness = Math.floor(Math.random() * 30) + 45; // 45-75% (nem muito escuro, nem muito claro)

                    const [r, g, b] = this.hslToRgb(hue, saturation, lightness);
                    const color = this.rgbToHex(r, g, b);

                    // Verifica se não é a cor reservada
                    if (reservedColor && color.toLowerCase() === reservedColor.toLowerCase()) {
                        attempts++;
                        continue;
                    }

                    // Verifica distância das cores já usadas
                    let isDistinct = true;
                    for (const usedColor of this.usedColors) {
                        const usedRgb = [
                            parseInt(usedColor.slice(1, 3), 16),
                            parseInt(usedColor.slice(3, 5), 16),
                            parseInt(usedColor.slice(5, 7), 16)
                        ];
                        
                        if (this.colorDistance([r, g, b], usedRgb) < this.minDistance) {
                            isDistinct = false;
                            break;
                        }
                    }

                    if (isDistinct) {
                        this.usedColors.add(color);
                        return color;
                    }

                    attempts++;
                }

                // Fallback: se não conseguir gerar cor distinta, gera uma aleatória
                const hue = Math.floor(Math.random() * 360);
                const [r, g, b] = this.hslToRgb(hue, 80, 60);
                const fallbackColor = this.rgbToHex(r, g, b);
                this.usedColors.add(fallbackColor);
                return fallbackColor;
            }

            // Limpa histórico de cores usadas
            reset() {
                this.usedColors.clear();
            }

            // Gera palette de cores distintas
            generatePalette(count, reservedColor = null) {
                this.reset();
                const palette = [];
                
                for (let i = 0; i < count; i++) {
                    palette.push(this.generateVibrantColor(reservedColor));
                }
                
                return palette;
            }
        }

        const disciplineColorGenerator = new ColorGenerator(); // Renomeado para clareza

        // Função para obter cor de uma disciplina (gera uma nova se não existir)
        function getDisciplineColor(disciplineId, cycleId) {
            if (!appData.cycles[cycleId]) return disciplineColorGenerator.generateVibrantColor(REPORT_RESERVED_COLOR);
            
            const cycle = appData.cycles[cycleId];
            if (!cycle.disciplineColors) cycle.disciplineColors = {};
            
            if (!cycle.disciplineColors[disciplineId]) {
                cycle.disciplineColors[disciplineId] = disciplineColorGenerator.generateVibrantColor(REPORT_RESERVED_COLOR);
                saveData(); // Salva a nova cor
            }
            
            return cycle.disciplineColors[disciplineId];
        }
        
        let appData = { cycles: {}, activeCycleId: null, allSubjects: [], allTags: [] };  
        let activeCycle = null;
        let allSubjects = new Set();
        let allTags = new Set();
        let timers = {};
        let currentCalendarDate = new Date();
        let selectedDate = null;
        let unsubscribe;
        let confirmCallback = null;
        let calendarViewMode = 'month';
        let selectedNewCycleColor = null; // Variável para armazenar a cor selecionada para o novo Projeto
        let recordToStop = null; // Armazena a referência ao registro de estudo que será parado
        let durationBarChart = null;
        let distributionDonutChart = null;
        let reportStartDate, reportEndDate;
        let reportDatePicker = null;
        let reportsInitialized = false;

    let activeTagFilter = ''; // Para armazenar a tag ativa que está sendo filtrada

        function renderAllTags() {
            const allTagsListEl = document.getElementById('allTagsList');
            allTagsListEl.innerHTML = ''; // Limpa a lista existente

            if (allTags.size === 0) {
                allTagsListEl.innerHTML = '<p style="color: #6c757d; font-size: 0.9em; margin: 0;">Nenhuma tag registrada ainda.</p>';
                return;
            }

            // Converte o Set para Array, ordena alfabeticamente e renderiza
            Array.from(allTags).sort((a, b) => a.localeCompare(b)).forEach(tag => {
                const tagItem = document.createElement('span');
                tagItem.className = 'tag-item';
                if (tag === activeTagFilter) {
                    tagItem.classList.add('active');
                }
                tagItem.textContent = tag;
                tagItem.onclick = () => selectTagForFilter(tag);
                allTagsListEl.appendChild(tagItem);
            });
        }

        function selectTagForFilter(tag) {
            if (activeTagFilter === tag) {
                activeTagFilter = ''; // Desseleciona a tag se for clicada novamente
            } else {
                activeTagFilter = tag; // Seleciona a nova tag
            }
            document.getElementById('tagSearchInput').value = ''; // Limpa a busca textual
            renderAllTags(); // Re-renderiza para atualizar o estado ativo
            filterTagsAndStudies(); // Filtra os estudos com a nova tag ativa
        }

        function filterTagsAndStudies() {
            const searchInput = document.getElementById('tagSearchInput').value.trim().toLowerCase();
            const tagResultsBody = document.getElementById('tagResultsBody');
            tagResultsBody.innerHTML = '';
            
            let studiesFound = false;

            const allStudyRecords = []; // Armazena todos os registros de estudo para processamento

            // Coleta todos os registros de estudo de todos os ciclos
            Object.values(appData.cycles || {}).forEach(cycle => {
                if (cycle.studyHistory) {
                    Object.entries(cycle.studyHistory).forEach(([dateStr, disciplineRecordsMap]) => {
                        Object.entries(disciplineRecordsMap).forEach(([discId, recordsArray]) => {
                            if (Array.isArray(recordsArray)) {
                                const discipline = cycle.disciplines.find(d => String(d.id) === discId);
                                if (discipline) {
                                    recordsArray.forEach(record => {
                                        allStudyRecords.push({
                                            cycleId: cycle.id,
                                            cycleColor: cycle.color,
                                            disciplineName: discipline.name,
                                            disciplineId: discipline.id,
                                            date: dateStr,
                                            time: record.time || 0,
                                            subject: record.subject || '',
                                            tags: record.tags || []
                                        });
                                    });
                                }
                            }
                        });
                    });
                }
            });

            // Filtra e agrupa os resultados
            const filteredAndGrouped = {}; // { tag: [ { studyRecord }, ... ] }
            const uniqueTagsMatchingSearch = new Set(); // Para mostrar apenas as tags relevantes

            allStudyRecords.forEach(study => {
                let matchesSearchInput = true;
                if (searchInput) {
                    // Busca por assunto, disciplina, projeto, ou tags
                    const searchLower = searchInput.toLowerCase();
                    const subjectLower = study.subject.toLowerCase();
                    const disciplineLower = study.disciplineName.toLowerCase();
                    const cycleLower = study.cycleId.toLowerCase();
                    const tagsLower = study.tags.map(t => t.toLowerCase()).join(' ');

                    if (!subjectLower.includes(searchLower) && 
                        !disciplineLower.includes(searchLower) && 
                        !cycleLower.includes(searchLower) &&
                        !tagsLower.includes(searchLower)) {
                        matchesSearchInput = false;
                    }
                }

                if (matchesSearchInput) {
                    study.tags.forEach(tag => {
                        const tagLower = tag.toLowerCase();
                        if (!activeTagFilter || tagLower === activeTagFilter.toLowerCase() || searchInput && tagLower.includes(searchInput)) {
                             // Considera a tag se ela corresponde ao filtro ativo OU à busca textual
                            if (!filteredAndGrouped[tag]) {
                                filteredAndGrouped[tag] = [];
                            }
                            filteredAndGrouped[tag].push(study);
                            if(activeTagFilter || searchInput) {
                                uniqueTagsMatchingSearch.add(tag); // Adiciona apenas tags que são relevantes para a busca/filtro
                            }
                        }
                    });

                    // Se não houver filtro de tag ou busca por tag, mas o estudo corresponder à busca geral (por assunto/disciplina/ciclo)
                    if (study.tags.length === 0 && matchesSearchInput && (searchInput && !activeTagFilter)) {
                         // Cria uma categoria "Sem Tags" ou mostra-o diretamente
                         if (!filteredAndGrouped['Sem Tags']) {
                            filteredAndGrouped['Sem Tags'] = [];
                         }
                         filteredAndGrouped['Sem Tags'].push(study);
                         uniqueTagsMatchingSearch.add('Sem Tags');
                    }
                }
            });

            const sortedTags = Array.from(Object.keys(filteredAndGrouped)).sort((a,b) => a.localeCompare(b));
            
            if (sortedTags.length === 0) {
                tagResultsBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado encontrado para o filtro atual.</p>';
            } else {
                sortedTags.forEach(tag => {
                    const tagStudies = filteredAndGrouped[tag].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()); // Ordena por data mais recente
                    let totalTimeForTag = tagStudies.reduce((sum, s) => sum + s.time, 0);

                    // Renderiza o cabeçalho da tag (se houver resultados ou se for uma tag que queremos destacar)
                    if (tagStudies.length > 0 || (searchInput && uniqueTagsMatchingSearch.has(tag))) {
                        const tagHeader = document.createElement('div');
                        tagHeader.className = 'breakdown-row cycle-row'; // Reusa o estilo, mas é para tags
                        tagHeader.innerHTML = `<div class="cycle-name-cell">
                                                <span class="material-icons-outlined toggle-arrow" onclick="toggleCycleDetails(this.parentNode.parentNode)">chevron_right</span>
                                                <span class="cycle-color-dot" style="background-color:${activeCycle ? activeCycle.color : '#CCCCCC'};"></span>
                                                <span>${tag}</span>
                                            </div>
                                            <span class="d-right">${formatTime(totalTimeForTag)}</span>`;
                        tagResultsBody.appendChild(tagHeader);

                        const studiesWrapper = document.createElement('div');
                        studiesWrapper.className = 'discipline-rows-wrapper'; // Reusa a classe para esconder/mostrar
                        tagStudies.forEach(study => {
                            studiesWrapper.innerHTML += `
                                <div class="tag-study-item">
                                    <div class="study-details">
                                        <span class="main-info">${study.subject || 'Sem Assunto'}</span>
                                        <span class="sub-info">${study.disciplineName} (${study.cycleId}) - ${new Date(study.date + 'T12:00:00').toLocaleDateString('pt-BR')}</span>
                                    </div>
                                    <span class="d-right">${formatTime(study.time)}</span>
                                </div>
                            `;
                        });
                        tagResultsBody.appendChild(studiesWrapper);
                        studiesFound = true;
                    }
                });
            }

            if (!studiesFound && sortedTags.length === 0) {
                tagResultsBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum resultado encontrado para o filtro atual.</p>';
            }
        }

     
       function getLocalDateString(date = new Date()) {
            // Cria um novo objeto Date que representa o início do dia NA HORA LOCAL
            const localDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            
            // Formata esta data local para YYYY-MM-DD
            if (typeof dateFns !== 'undefined' && dateFns.format) {
                return dateFns.format(localDate, 'yyyy-MM-dd');
            } else {
                // Fallback mais robusto para garantir a data local, se dateFns não estiver disponível
                const year = localDate.getFullYear();
                const month = (localDate.getMonth() + 1).toString().padStart(2, '0');
                const day = localDate.getDate().toString().padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
        }

        async function handleAuth() {
            console.log("handleAuth: Iniciando verificação de autenticação...");
            auth.onAuthStateChanged(async (user) => {
                const sidebar = document.querySelector('.sidebar-nav');
                const mainContent = document.querySelector('.main-content');
                if (user) {
                    console.log("handleAuth: Usuário autenticado. UID:", user.uid);
                    sidebar.style.display = 'flex';
                    mainContent.style.marginLeft = getComputedStyle(sidebar).width;
                    await loadUserData(user.uid);
                } else {
                    console.log("handleAuth: Usuário não autenticado.");
                    if (unsubscribe) {
                        unsubscribe();
                        unsubscribe = null; 
                    }
                    activeCycle = null;
                    appData = { cycles: {}, activeCycleId: null };
                    Object.values(timers).forEach(clearInterval);
                    timers = {};
                    reportsInitialized = false;
                    
                    sidebar.style.display = 'none';
                    mainContent.style.marginLeft = '0';
                    switchView('login');
                }
            });
            try { 
                await auth.getRedirectResult(); 
            } catch (error) { 
                console.error("handleAuth: Erro no redirecionamento de autenticação:", error); 
            }
        }

        function signInWithGoogle() { 
            auth.signInWithPopup(provider).catch((error) => {
                console.error("signInWithGoogle: Erro no login:", error);
                showAlertModal('Erro de Login', `Não foi possível fazer login com o Google. Erro: ${error.message}`);
            }); 
        }

        function signOutUser() { 
            auth.signOut().catch((error) => {
                console.error("signOutUser: Erro ao deslogar:", error);
                showAlertModal('Erro ao Sair', `Não foi possível sair. Erro: ${error.message}`);
            });
        }

        async function loadUserData(userId) {
            if (unsubscribe) unsubscribe();
            const userDocRef = db.collection('users').doc(userId);
            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    // Inicializa com as novas propriedades se o documento não existir
                    await userDocRef.set({ cycles: {}, activeCycleId: null, allSubjects: [], allTags: [] }); 
                }
                unsubscribe = userDocRef.onSnapshot(snapshot => {
                    if (!snapshot.exists) return;
                    appData = snapshot.data();
                    
                    // Carrega assuntos e tags do Firestore
                    allSubjects = new Set(appData.allSubjects || []);
                    allTags = new Set(appData.allTags || []);

                    Object.values(timers).forEach(clearInterval);
                    timers = {};
                    if (appData.activeCycleId && appData.cycles[appData.activeCycleId]) {
                        activeCycle = appData.cycles[appData.activeCycleId];
                        switchView('current');
                        updateDisplay();
                    } else {
                        activeCycle = null; 
                        populateCycleSelector();
                        renderCycleColorPalette();
                        renderExistingCyclesDisplay();
                        switchView('cycle-selection');
                    }
                }, error => {
                    console.error("loadUserData: Erro no listener do Firestore:", error);
                    showAlertModal('Erro de Conexão', 'Não foi possível carregar seus dados.');
                });
            } catch (error) {
                 console.error("loadUserData: Erro ao carregar dados do usuário:", error);
                 showAlertModal('Erro Crítico', 'Não foi possível carregar seus dados.');
            }
        }

       function saveData() {
            if (auth.currentUser) {
                const userId = auth.currentUser.uid;
                const dataToSave = JSON.parse(JSON.stringify(appData));
                if(dataToSave.activeCycleId && dataToSave.cycles[dataToSave.activeCycleId]) {
                    dataToSave.cycles[dataToSave.activeCycleId].disciplines.forEach(d => d.isRunning = false);
                }
                
                // Recalcula allSubjects e allTags ANTES de salvar
                recalculateAllSubjectsAndTags(); // <--- CHAME AQUI
                
                // Salva os sets de assuntos e tags como arrays
                dataToSave.allSubjects = Array.from(allSubjects);
                dataToSave.allTags = Array.from(allTags);

                db.collection('users').doc(userId).set(dataToSave).catch(error => {
                    console.error("saveData: Erro ao salvar dados:", error);
                    showAlertModal('Erro ao Salvar', 'Não foi possível salvar suas alterações.');
                });
            }
        }

        function updateAllSubjectsAndTags(subject, tags) {
            if (subject) {
                allSubjects.add(subject);
            }
            tags.forEach(tag => allTags.add(tag));
            
        }

        function recalculateAllSubjectsAndTags() {
            allSubjects.clear(); // Limpa os sets existentes
            allTags.clear();

            Object.values(appData.cycles || {}).forEach(cycle => {
                if (cycle.studyHistory) {
                    Object.values(cycle.studyHistory).forEach(dailyRecordsMap => {
                        Object.values(dailyRecordsMap).forEach(disciplineRecordsArray => {
                            if (Array.isArray(disciplineRecordsArray)) {
                                disciplineRecordsArray.forEach(record => {
                                    if (record.subject) {
                                        allSubjects.add(record.subject);
                                    }
                                    if (record.tags && Array.isArray(record.tags)) {
                                        record.tags.forEach(tag => allTags.add(tag));
                                    }
                                });
                            }
                        });
                    });
                }
            });
        }

        function populateSubjectRecommendations() {
            const datalist = document.getElementById('subjectRecommendations');
            if (!datalist) return;
            datalist.innerHTML = '';
            // Converte o Set para Array e ordena alfabeticamente
            Array.from(allSubjects).sort().forEach(subject => {
                const option = document.createElement('option');
                option.value = subject;
                datalist.appendChild(option);
            });
        }
        
        function returnToCycleSelection() {
            Object.keys(timers).forEach(id => stopTimer(id, false));
            if (appData.activeCycleId !== null) {
                appData.activeCycleId = null;
                saveData();
            }
            populateCycleSelector();
            renderCycleColorPalette(); // Renderiza a paleta de cores novamente
            renderExistingCyclesDisplay(); // Exibe os Projetos existentes com suas cores
            switchView('cycle-selection');
        }

        function populateCycleSelector() {
            const selector = document.getElementById('existingCycleSelector');
            selector.innerHTML = '<option value="">-- Selecione um Projeto --</option>';
            const cycleIds = Object.keys(appData.cycles || {});
            if (cycleIds.length > 0) {
                cycleIds.forEach(id => selector.innerHTML += `<option value="${id}">${id}</option>`);
                selector.disabled = false;
                selector.parentElement.nextElementSibling.disabled = false;
            } else {
                selector.innerHTML = '<option value="">Nenhum Projeto criado</option>';
                selector.disabled = true;
                selector.parentElement.nextElementSibling.disabled = true;
            }
        }

        function renderCycleColorPalette() {
            const paletteContainer = document.getElementById('cycleColorPalette');
            paletteContainer.innerHTML = '';
            CYCLE_COLOR_PALETTE.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = color;
                colorBox.setAttribute('data-color', color);
                colorBox.onclick = () => selectCycleColor(color);
                paletteContainer.appendChild(colorBox);
            });

            // Seleciona a primeira cor por padrão se nenhuma estiver selecionada
            if (!selectedNewCycleColor) {
                selectCycleColor(CYCLE_COLOR_PALETTE[0]);
            } else {
                // Se já houver uma cor selecionada, garante que ela apareça como selecionada
                const selectedBox = paletteContainer.querySelector(`[data-color="${selectedNewCycleColor}"]`);
                if (selectedBox) {
                    selectedBox.classList.add('selected');
                }
            }
        }

        function selectCycleColor(color) {
            selectedNewCycleColor = color;
            document.querySelectorAll('.color-box').forEach(box => {
                box.classList.remove('selected');
            });
            const selectedBox = document.querySelector(`.color-box[data-color="${color}"]`);
            if (selectedBox) {
                selectedBox.classList.add('selected');
            }
        }

        function renderExistingCyclesDisplay() {
            const existingCyclesDisplay = document.getElementById('existingCyclesDisplay');
            existingCyclesDisplay.innerHTML = '';
            const cycleIds = Object.keys(appData.cycles || {});
            if (cycleIds.length > 0) {
                cycleIds.forEach(id => {
                    const cycle = appData.cycles[id];
                    if (cycle && cycle.color) {
                        const cycleItem = document.createElement('div');
                        cycleItem.className = 'existing-cycle-item';
                        cycleItem.innerHTML = `<span class="cycle-color-dot" style="background-color:${cycle.color};"></span><span>${id}</span>`;
                        existingCyclesDisplay.appendChild(cycleItem);
                    }
                });
            } else {
                existingCyclesDisplay.innerHTML = '<p style="margin: 0; color: #6c757d;">Nenhum Projeto criado ainda.</p>';
            }
        }

        function loadSelectedCycle() {
            const selectedId = document.getElementById('existingCycleSelector').value;
            if (selectedId && appData.cycles[selectedId]) {
                appData.activeCycleId = selectedId;
                saveData(); 
            } else {
                showAlertModal('Seleção Inválida', 'Por favor, selecione um Projeto válido para carregar.');
            }
        }
        
        function createNewCycle() {
            const newName = document.getElementById('newCycleNameInput').value.trim();
            if (!newName) { 
                showAlertModal('Nome Inválido', 'Por favor, dê um nome ao novo Projeto.'); 
                return; 
            }
            if (appData.cycles[newName]) { 
                showAlertModal('Nome Duplicado', 'Já existe um Projeto com esse nome.'); 
                return; 
            }
            if (!selectedNewCycleColor) {
                showAlertModal('Cor Inválida', 'Por favor, selecione uma cor para o novo Projeto.');
                return;
            }

            appData.cycles[newName] = { 
                id: newName, 
                disciplines: [], 
                completions: 0, 
                studyHistory: {},
                disciplineColors: {}, // Campo para armazenar cores das disciplinas (ainda aleatórias)
                color: selectedNewCycleColor // Armazena a cor escolhida para o Projeto
            };
            appData.activeCycleId = newName;
            saveData();
        }

        function deleteCurrentCycle() {
            if (!activeCycle) return;
            showConfirmModal(
                'Apagar Projeto',
                `Tem certeza que deseja apagar o Projeto '${activeCycle.id}'? Esta ação é irreversível.`,
                () => {
                    Object.keys(timers).forEach(id => stopTimer(id, false));
                    delete appData.cycles[activeCycle.id];
                    appData.activeCycleId = null;
                    activeCycle = null;
                    saveData();
                }
            );
        }

        function addDiscipline() {
            if (!activeCycle) {
                showAlertModal('Nenhum Projeto Ativo', 'Crie um Projeto antes de adicionar disciplinas.');
                return;
            }
            const nameInput = document.getElementById('disciplineInput');
            const hours = parseInt(document.getElementById('hoursInput').value, 10) || 0;
            const minutes = parseInt(document.getElementById('minutesInput').value, 10) || 0;
            const disciplineName = nameInput.value.trim();
            const targetSeconds = (hours * 3600) + (minutes * 60);

            if (!disciplineName || targetSeconds <= 0) { 
                showAlertModal('Dados Inválidos', 'Insira um nome e uma meta de tempo válida.');
                return; 
            }
            if (activeCycle.disciplines.some(d => d.name.toLowerCase() === disciplineName.toLowerCase())) {
                showAlertModal('Nome Duplicado', 'Já existe uma disciplina com esse nome.');
                return; 
            }

            const newDisciplineId = Date.now();
            activeCycle.disciplines.push({ 
                id: newDisciplineId, 
                name: disciplineName, 
                currentSeconds: 0, 
                targetSeconds: targetSeconds, 
                isRunning: false 
            });
            
            // Gera uma cor aleatória para a nova disciplina
            getDisciplineColor(newDisciplineId, activeCycle.id);
            
            nameInput.value = '';
            document.getElementById('hoursInput').value = '1';
            document.getElementById('minutesInput').value = '0';
            saveData();
        }
        
        function removeDiscipline(id) {
            if (!activeCycle) return;
            showConfirmModal(
                'Remover Disciplina',
                'Tem certeza que deseja remover esta disciplina?',
                () => {
                    if (timers[id]) stopTimer(id, false);
                    activeCycle.disciplines = activeCycle.disciplines.filter(d => d.id !== id);
                    // Remove a cor da disciplina também
                    if (activeCycle.disciplineColors && activeCycle.disciplineColors[id]) {
                        delete activeCycle.disciplineColors[id];
                    }
                    saveData();
                }
            );
        }
        
        function manuallyEndCycle() {
            if (!activeCycle) return;
            showConfirmModal(
                'Encerrar Projeto Manualmente',
                'Deseja encerrar este Projeto? Ele será contabilizado como concluído.',
                () => {
                    hideConfirmModal(); 
                    handleStartNewCycle(); 
                }
            );
        }

        function startTimer(id) {
            if (!activeCycle) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline || discipline.isRunning) return;
            activeCycle.disciplines.forEach(d => { if (d.isRunning) stopTimer(d.id, false); });
            discipline.isRunning = true;
            updateDisciplinesList();
            timers[id] = setInterval(() => {
                discipline.currentSeconds += 1;
                const today = getLocalDateString();
                if (!activeCycle.studyHistory[today]) activeCycle.studyHistory[today] = {};
                const discIdStr = String(discipline.id);
                activeCycle.studyHistory[today][discIdStr] = (activeCycle.studyHistory[today][discIdStr] || 0) + 1; 
                updateTimerDisplay(discipline);
            }, 1000);
        }

        function stopTimer(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;
            
            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }
            
            if (doSave) saveData();
            updateDisciplinesList();
        }

        function checkCycleCompletion() {
            if (!activeCycle || activeCycle.disciplines.length === 0) return false;
            return activeCycle.disciplines.every(d => d.currentSeconds >= d.targetSeconds);
        }

        function showCompletionModal() { document.getElementById('completionModal').style.display = 'flex'; }
        function hideCompletionModal() { document.getElementById('completionModal').style.display = 'none'; }

        function handleStartNewCycle() {
            if (!activeCycle) return;
            hideCompletionModal();
            activeCycle.completions = (activeCycle.completions || 0) + 1;
            activeCycle.disciplines.forEach(d => { d.currentSeconds = 0; });
            saveData();
            updateDisplay();
            showCelebrationModal();
        }

        function handleContinueCycle() { hideCompletionModal(); }
        function showCelebrationModal() { document.getElementById('celebrationModal').style.display = 'flex'; }
        function hideCelebrationModal() { document.getElementById('celebrationModal').style.display = 'none'; }
        function showAlertModal(title, message) {
            document.getElementById('alertModalTitle').textContent = title;
            document.getElementById('alertModalMessage').textContent = message;
            document.getElementById('alertModal').style.display = 'flex';
        }
        function hideAlertModal() { document.getElementById('alertModal').style.display = 'none'; }
        
        let disciplineIdToAddTime = null; // Para armazenar o ID da disciplina que terá tempo adicionado

        function openAddTimeModal(id) {
            disciplineIdToAddTime = id;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;

            // Opcional: pré-preencher com 0, ou algum valor inicial se desejar
            document.getElementById('addTimeHoursInput').value = 0;
            document.getElementById('addTimeMinutesInput').value = 0;
            document.getElementById('addTimeSecondsInput').value = 0;
            document.getElementById('addTimeDisciplineId').value = id;
            
            document.getElementById('addTimeSubjectInput').value = '';
            document.getElementById('addTimeTagsInput').value = '';
            document.getElementById('addTimeStopPoint').value = ''; // Nova linha: Limpa o campo
            
            populateSubjectRecommendations();
            document.getElementById('addTimeModal').style.display = 'flex';
        }

        function hideAddTimeModal() {
            document.getElementById('addTimeModal').style.display = 'none';
            disciplineIdToAddTime = null;
        }
        
        function saveAddedTime() {
            if (!disciplineIdToAddTime || !activeCycle) {
                showAlertModal('Erro', 'Nenhuma disciplina selecionada para adicionar tempo.');
                return;
            }

            const discipline = activeCycle.disciplines.find(d => d.id === disciplineIdToAddTime);
            if (!discipline) {
                showAlertModal('Erro', 'Disciplina não encontrada.');
                return;
            }

            const hoursToAdd = parseInt(document.getElementById('addTimeHoursInput').value, 10) || 0;
            const minutesToAdd = parseInt(document.getElementById('addTimeMinutesInput').value, 10) || 0;
            const secondsToAddInput = parseInt(document.getElementById('addTimeSecondsInput').value, 10) || 0;
            const totalSecondsToAdd = (hoursToAdd * 3600) + (minutesToAdd * 60) + secondsToAddInput;
            
            const subject = document.getElementById('addTimeSubjectInput').value.trim();
            const tagsInput = document.getElementById('addTimeTagsInput').value.trim();
            const tags = tagsInput.split(/[\s,]+/).filter(tag => tag !== '');

            const stopPoint = document.getElementById('addTimeStopPoint').value.trim(); // Nova linha

            if (totalSecondsToAdd <= 0) {
                showAlertModal('Tempo Inválido', 'Por favor, insira um tempo válido (horas, minutos ou segundos) para adicionar.');
                return;
            }

            // Adiciona ao currentSeconds da disciplina
            discipline.currentSeconds += totalSecondsToAdd;

            // Atualiza o histórico de estudo do dia atual com a nova estrutura
            const today = getLocalDateString();
            if (!activeCycle.studyHistory[today]) {
                activeCycle.studyHistory[today] = {};
            }
            const discIdStr = String(discipline.id);
            if (!activeCycle.studyHistory[today][discIdStr] || !Array.isArray(activeCycle.studyHistory[today][discIdStr])) {
                activeCycle.studyHistory[today][discIdStr] = [];
            }
            activeCycle.studyHistory[today][discIdStr].push({ // Adiciona um objeto com tempo, assunto e tags
                time: totalSecondsToAdd,
                subject: subject,
                tags: tags,
                timestamp: Date.now(),
                stopPoint: stopPoint // Nova propriedade
            });
            
            // Armazena todos os assuntos e tags para recomendações futuras
            updateAllSubjectsAndTags(subject, tags);

            hideAddTimeModal();
            saveData();
            updateDisplay();
            showAlertModal('Sucesso', `Tempo adicionado com sucesso à disciplina "${discipline.name}".`);
        }
        let selectedDateForManualAdd = null; // Armazena a data selecionada no calendário
        function openStopTimerModal(disciplineId, dateStr, recordIndex, cycleId) {
            const discipline = activeCycle.disciplines.find(d => d.id === disciplineId);
            if (!discipline) return;

            // Encontra a referência ao registro específico que está sendo parado
            const cycle = appData.cycles[cycleId];
            if (!cycle || !cycle.studyHistory || !cycle.studyHistory[dateStr] || !cycle.studyHistory[dateStr][disciplineId]) return;
            const records = cycle.studyHistory[dateStr][disciplineId];
            if (!Array.isArray(records) || recordIndex < 0 || recordIndex >= records.length) return;

            recordToStop = records[recordIndex]; // Salva a referência direta ao objeto no histórico

            document.getElementById('stopTimerDisciplineName').textContent = discipline.name;
            document.getElementById('stopTimerDisciplineId').value = disciplineId;
            document.getElementById('stopTimerStudyRecordIndex').value = recordIndex; // Para referência futura
            document.getElementById('stopTimerStudyDate').value = dateStr;
            document.getElementById('stopTimerStudyCycleId').value = cycleId;

            document.getElementById('stopTimerStopPoint').value = recordToStop.stopPoint || ''; // Preenche se já houver

            document.getElementById('stopTimerModal').style.display = 'flex';
        }

        function hideStopTimerModal() {
            document.getElementById('stopTimerModal').style.display = 'none';
            recordToStop = null;
        }

        function cancelStopTimer() {
            // Se o usuário cancelar a pausa, o timer continua rodando
            hideStopTimerModal();
        }

        function confirmStopTimer() {
            const id = parseInt(document.getElementById('stopTimerDisciplineId').value, 10);
            const stopPoint = document.getElementById('stopTimerStopPoint').value.trim();
            const recordIndex = parseInt(document.getElementById('stopTimerStudyRecordIndex').value, 10);
            const dateStr = document.getElementById('stopTimerStudyDate').value;
            const cycleId = document.getElementById('stopTimerStudyCycleId').value;

            // Atualiza o stopPoint no registro de estudo
            if (recordToStop) {
                recordToStop.stopPoint = stopPoint;
            } else {
                // Fallback caso recordToStop por algum motivo não esteja setado (o que não deveria acontecer)
                const cycle = appData.cycles[cycleId];
                if (cycle && cycle.studyHistory && cycle.studyHistory[dateStr] && cycle.studyHistory[dateStr][id]) {
                    const records = cycle.studyHistory[dateStr][id];
                    if (Array.isArray(records) && records.length > recordIndex) {
                        records[recordIndex].stopPoint = stopPoint;
                    }
                }
            }

            hideStopTimerModal();
            realStopTimerForReal(id, true); // Chama a função que realmente para o timer e salva
        }

        // Renomeie sua função stopTimer existente para realStopTimerForReal
        function realStopTimerForReal(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;

            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }

            if (doSave) saveData();
            updateDisciplinesList();
        }
        function openAddTimeToDayModal(dateStr) {
            selectedDateForManualAdd = dateStr;
            document.getElementById('addTimeToDayModalDate').textContent = new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR');
            document.getElementById('addTimeToDaySelectedDate').value = dateStr;
            
            populateAddTimeToDayCycles();
            
            // Resetar campos
            document.getElementById('addTimeToDayCycleSelect').value = '';
            document.getElementById('addTimeToDayDisciplineSelect').innerHTML = '<option value="">-- Selecione um Projeto primeiro --</option>';
            document.getElementById('addTimeToDayHoursInput').value = 0;
            document.getElementById('addTimeToDayMinutesInput').value = 0;
            document.getElementById('addTimeToDaySecondsInput').value = 0;
            
            document.getElementById('addTimeToDaySubjectInput').value = '';
            document.getElementById('addTimeToDayTagsInput').value = '';
            document.getElementById('addTimeToDayStopPoint').value = ''; // Nova linha: Limpa o campo

            populateSubjectRecommendations();
            document.getElementById('addTimeToDayModal').style.display = 'flex';
        }

        function hideAddTimeToDayModal() {
            document.getElementById('addTimeToDayModal').style.display = 'none';
            selectedDateForManualAdd = null;
        }

        


        function populateAddTimeToDayCycles() {
            const cycleSelect = document.getElementById('addTimeToDayCycleSelect');
            cycleSelect.innerHTML = '<option value="">-- Selecione um Projeto --</option>';
            const cycleIds = Object.keys(appData.cycles || {});
            cycleIds.forEach(id => {
                cycleSelect.innerHTML += `<option value="${id}">${id}</option>`;
            });
            // Opcional: pré-selecionar o Projeto ativo se houver
            if (activeCycle) {
                cycleSelect.value = activeCycle.id;
                populateAddTimeToDayDisciplines(); // Popula disciplinas se um Projeto já foi selecionado
            }
        }

        function populateAddTimeToDayDisciplines() {
            const cycleId = document.getElementById('addTimeToDayCycleSelect').value;
            const disciplineSelect = document.getElementById('addTimeToDayDisciplineSelect');
            disciplineSelect.innerHTML = '<option value="">-- Selecione uma disciplina --</option>';

            if (cycleId && appData.cycles[cycleId]) {
                const cycle = appData.cycles[cycleId];
                cycle.disciplines.forEach(d => {
                    disciplineSelect.innerHTML += `<option value="${d.id}">${d.name}</option>`;
                });
            }
        }

function saveAddTimeToDayEntry() {
            const dateStr = document.getElementById('addTimeToDaySelectedDate').value;
            const cycleId = document.getElementById('addTimeToDayCycleSelect').value;
            const disciplineId = parseInt(document.getElementById('addTimeToDayDisciplineSelect').value, 10);
            const hoursToAdd = parseInt(document.getElementById('addTimeToDayHoursInput').value, 10) || 0;
            const minutesToAdd = parseInt(document.getElementById('addTimeToDayMinutesInput').value, 10) || 0;
            const secondsToAddInput = parseInt(document.getElementById('addTimeToDaySecondsInput').value, 10) || 0;
            const totalSecondsToAdd = (hoursToAdd * 3600) + (minutesToAdd * 60) + secondsToAddInput;

            const subject = document.getElementById('addTimeToDaySubjectInput').value.trim();
            const tagsInput = document.getElementById('addTimeToDayTagsInput').value.trim();
            const tags = tagsInput.split(/[\s,]+/).filter(tag => tag !== '');

            const stopPoint = document.getElementById('addTimeToDayStopPoint').value.trim(); // Nova linha

            if (!dateStr || !cycleId || !disciplineId || totalSecondsToAdd <= 0) {
                showAlertModal('Dados Inválidos', 'Por favor, preencha todos os campos e insira um tempo válido.');
                return;
            }

            const cycle = appData.cycles[cycleId];
            if (!cycle) {
                showAlertModal('Erro', 'Projeto não encontrado.');
                return;
            }

            const discipline = cycle.disciplines.find(d => d.id === disciplineId);
            if (!discipline) {
                showAlertModal('Erro', 'Disciplina não encontrada no Projeto selecionado.');
                return;
            }

            // Atualiza o currentSeconds da disciplina (tempo total estudado para essa disciplina)
            discipline.currentSeconds += totalSecondsToAdd;

            // Atualiza o histórico de estudo para a data específica com a nova estrutura
            if (!cycle.studyHistory[dateStr]) {
                cycle.studyHistory[dateStr] = {};
            }
            const discIdStr = String(discipline.id);
            if (!cycle.studyHistory[dateStr][discIdStr] || !Array.isArray(cycle.studyHistory[dateStr][discIdStr])) {
                cycle.studyHistory[dateStr][discIdStr] = [];
            }
            cycle.studyHistory[dateStr][discIdStr].push({ // Adiciona um objeto com tempo, assunto e tags
                time: totalSecondsToAdd,
                subject: subject,
                tags: tags,
                timestamp: Date.now(),
                stopPoint: stopPoint // Nova propriedade
            });
            
            // Armazena todos os assuntos e tags para recomendações futuras
            updateAllSubjectsAndTags(subject, tags);

            hideAddTimeToDayModal();
            saveData();
            selectDate(dateStr);
            if (activeCycle && activeCycle.id === cycleId) updateDisplay();
            showAlertModal('Sucesso', `Tempo adicionado em "${discipline.name}" para ${new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR')}.`);
        }

        function hideAddTimeModal() {
            document.getElementById('addTimeModal').style.display = 'none';
            disciplineIdToAddTime = null;
        }

function saveAddedTime() {
            if (!disciplineIdToAddTime || !activeCycle) {
                showAlertModal('Erro', 'Nenhuma disciplina selecionada para adicionar tempo.');
                return;
            }

            const discipline = activeCycle.disciplines.find(d => d.id === disciplineIdToAddTime);
            if (!discipline) {
                showAlertModal('Erro', 'Disciplina não encontrada.');
                return;
            }

            const hoursToAdd = parseInt(document.getElementById('addTimeHoursInput').value, 10) || 0;
            const minutesToAdd = parseInt(document.getElementById('addTimeMinutesInput').value, 10) || 0;
            const secondsToAddInput = parseInt(document.getElementById('addTimeSecondsInput').value, 10) || 0;
            const totalSecondsToAdd = (hoursToAdd * 3600) + (minutesToAdd * 60) + secondsToAddInput;
            
            const subject = document.getElementById('addTimeSubjectInput').value.trim(); // Nova linha
            const tagsInput = document.getElementById('addTimeTagsInput').value.trim();   // Nova linha
            const tags = tagsInput.split(/[\s,]+/).filter(tag => tag !== '');          // Nova linha

            if (totalSecondsToAdd <= 0) {
                showAlertModal('Tempo Inválido', 'Por favor, insira um tempo válido (horas, minutos ou segundos) para adicionar.');
                return;
            }

            // Adiciona ao currentSeconds da disciplina
            discipline.currentSeconds += totalSecondsToAdd;

            // Atualiza o histórico de estudo do dia atual com a nova estrutura
            const today = getLocalDateString();
            if (!activeCycle.studyHistory[today]) {
                activeCycle.studyHistory[today] = {};
            }
            const discIdStr = String(discipline.id);
            if (!activeCycle.studyHistory[today][discIdStr] || !Array.isArray(activeCycle.studyHistory[today][discIdStr])) {
                activeCycle.studyHistory[today][discIdStr] = [];
            }
            activeCycle.studyHistory[today][discIdStr].push({ // Adiciona um objeto com tempo, assunto e tags
                time: totalSecondsToAdd,
                subject: subject,
                tags: tags,
                timestamp: Date.now()
            });
            
            // Armazena todos os assuntos e tags para recomendações futuras
            updateAllSubjectsAndTags(subject, tags);

            hideAddTimeModal();
            saveData();
            updateDisplay();
            showAlertModal('Sucesso', `Tempo adicionado com sucesso à disciplina "${discipline.name}".`);
        }

        function showConfirmModal(title, message, callback) {
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalMessage').textContent = message;
            confirmCallback = callback;
            document.getElementById('confirmModal').style.display = 'flex';
        }
        function hideConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }
        function handleConfirmAction() {
            if (typeof confirmCallback === 'function') confirmCallback();
            hideConfirmModal();
        }
        
        function openEditModal(id) {
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;
            
            document.getElementById('editDisciplineId').value = discipline.id;
            document.getElementById('editDisciplineName').value = discipline.name;

            const hours = Math.floor(discipline.targetSeconds / 3600);
            const minutes = Math.floor((discipline.targetSeconds % 3600) / 60);
            document.getElementById('editHoursInput').value = hours;
            document.getElementById('editMinutesInput').value = minutes;

            document.getElementById('editDisciplineModal').style.display = 'flex';
        }

        function hideEditModal() {
            document.getElementById('editDisciplineModal').style.display = 'none';
        }
        let disciplineIdToStartTimer = null; // Armazena o ID da disciplina para o timer

        function openStartTimerModal(id) {
            disciplineIdToStartTimer = id;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;

            document.getElementById('startTimerDisciplineName').textContent = discipline.name;
            document.getElementById('startTimerDisciplineId').value = id;
            document.getElementById('startTimerSubjectInput').value = '';
            document.getElementById('startTimerTagsInput').value = '';
            
            // Limpa o campo de ponto de parada, caso exista ou esteja em cache de alguma forma
            const stopPointInput = document.getElementById('startTimerStopPoint');
            if (stopPointInput) { // Verifica se o elemento existe antes de tentar acessar .value
                stopPointInput.value = '';
            }

            populateSubjectRecommendations();
            
            document.getElementById('startTimerModal').style.display = 'flex';
        }

        function hideStartTimerModal() {
            document.getElementById('startTimerModal').style.display = 'none';
            disciplineIdToStartTimer = null;
        }

        function confirmStartTimer() {
            const id = parseInt(document.getElementById('startTimerDisciplineId').value, 10);
            const subject = document.getElementById('startTimerSubjectInput').value.trim();
            const tagsInput = document.getElementById('startTimerTagsInput').value.trim();
            const tags = tagsInput.split(/[\s,]+/).filter(tag => tag !== '');

            hideStartTimerModal(); // Esconde o modal antes de iniciar o timer

            // Agora, chame a função startTimer com os novos parâmetros
            realStartTimer(id, subject, tags); 
        }

        // Renomeie sua função startTimer existente para realStartTimer
function realStartTimer(id, subject = '', tags = []) { 
            if (!activeCycle) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline || discipline.isRunning) return;

            activeCycle.disciplines.forEach(d => { if (d.isRunning) stopTimer(d.id, false); });
            discipline.isRunning = true;
            updateDisciplinesList();

            const today = getLocalDateString();
            if (!activeCycle.studyHistory[today]) activeCycle.studyHistory[today] = {};
            const discIdStr = String(discipline.id);

            if (!activeCycle.studyHistory[today][discIdStr] || !Array.isArray(activeCycle.studyHistory[today][discIdStr])) {
                activeCycle.studyHistory[today][discIdStr] = [];
            }

            const newStudyRecord = {
                time: 0, 
                subject: subject,
                tags: tags,
                timestamp: Date.now(), 
                stopPoint: '' // Inicializa vazio, será preenchido ao parar
            };
            activeCycle.studyHistory[today][discIdStr].push(newStudyRecord);

            updateAllSubjectsAndTags(subject, tags);

            timers[id] = setInterval(() => {
                const currentDisc = activeCycle.disciplines.find(d => d.id === id);
                if (currentDisc && activeCycle.studyHistory[today] && activeCycle.studyHistory[today][discIdStr]) {
                    const records = activeCycle.studyHistory[today][discIdStr];
                    if (records.length > 0) {
                        const lastRecord = records[records.length - 1];
                        lastRecord.time += 1; 
                        currentDisc.currentSeconds += 1; 
                        updateTimerDisplay(currentDisc);
                    }
                }
            }, 1000);
        }

        // Adapte a função stopTimer para não mais usar o currentSeconds do studyHistory diretamente
        function stopTimer(id, doSave = true) {
            if (!activeCycle || !timers[id]) return;
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            clearInterval(timers[id]);
            delete timers[id];
            if (discipline) discipline.isRunning = false;
            
            // Não precisamos mais atualizar activeCycle.studyHistory[today][discIdStr] aqui
            // A atualização já foi feita no setInterval para o registro específico.

            if (doSave && checkCycleCompletion()) {
                showCompletionModal();
            }
            
            if (doSave) saveData();
            updateDisciplinesList();
        }

        function saveDisciplineChanges() {
            const id = parseInt(document.getElementById('editDisciplineId').value, 10);
            const newName = document.getElementById('editDisciplineName').value.trim();
            const newHours = parseInt(document.getElementById('editHoursInput').value, 10) || 0;
            const newMinutes = parseInt(document.getElementById('editMinutesInput').value, 10) || 0;
            const newTargetSeconds = (newHours * 3600) + (newMinutes * 60);

            if (!newName || newTargetSeconds <= 0) {
                showAlertModal('Dados Inválidos', 'O nome e a meta de tempo devem ser válidos.');
                return;
            }

            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (discipline) {
                discipline.name = newName;
                discipline.targetSeconds = newTargetSeconds;
                saveData();
                updateDisplay();
                hideEditModal();
            }
        }

        function toggleTimer(id) {
            const discipline = activeCycle.disciplines.find(d => d.id === id);
            if (!discipline) return;
            if (discipline.isRunning) {
                // Obtém a data e o índice do último registro para abrir o modal de parada
                const today = getLocalDateString();
                const discIdStr = String(discipline.id);
                let recordIndex = -1;
                if (activeCycle.studyHistory[today] && activeCycle.studyHistory[today][discIdStr]) {
                    const records = activeCycle.studyHistory[today][discIdStr];
                    if (records.length > 0) {
                        // Encontra o último registro que corresponde ao timer ativo
                        // Pode ser necessário um critério mais robusto se múltiplos timers forem possíveis
                        recordIndex = records.length - 1; // Assume que o último registro é o que está ativo
                    }
                }
                if (recordIndex !== -1) {
                     // Abre o modal de parada para coletar o ponto de parada
                    openStopTimerModal(id, today, recordIndex, activeCycle.id);
                } else {
                    // Fallback: se não encontrar registro, para sem pedir ponto de parada (pode ser um erro)
                    realStopTimerForReal(id, true);
                }
            } else {
                // Abre o modal para inserir assunto/tags antes de iniciar
                openStartTimerModal(id);
            }
        }

        function switchView(viewName) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${viewName}-view`).classList.add('active');
            
            const sidebar = document.querySelector('.sidebar-nav');
            const mainContent = document.querySelector('.main-content');
            if (viewName === 'login' || viewName === 'loading') {
                 sidebar.style.display = 'none';
                 mainContent.style.marginLeft = '0';
            } else {
                sidebar.style.display = 'flex';
                mainContent.style.marginLeft = getComputedStyle(sidebar).width;
                document.querySelectorAll('.sidebar-menu li').forEach(t => t.classList.remove('active'));
                const activeTab = document.querySelector(`.sidebar-menu li[data-view='${viewName}']`);
                if(activeTab) activeTab.classList.add('active');
            }
            
            if (viewName === 'calendar') renderCalendar();
            if (viewName === 'reports') {
                if (!reportsInitialized) initializeReportFilters();
                renderReportsView(); 
            }
            if (viewName === 'tags') { // NOVO
                renderAllTags();
                filterTagsAndStudies(); // Carrega todos os estudos inicialmente ou com filtro padrão
            }
        }

        function updateDisplay() {
            if (!activeCycle) return;
            document.getElementById('cycleTitleText').textContent = `Projeto: ${activeCycle.id}`;
            updateStats();
            updateDisciplinesList();
            createWheelChart();
        }
        
function updateStats() {
            if (!activeCycle) return;

            document.getElementById('cycleCompletions').textContent = activeCycle.completions || 0;
            document.getElementById('totalDisciplines').textContent = activeCycle.disciplines.length;

            const today = getLocalDateString();
            let totalSecondsStudiedTodayAllCycles = 0;

            // Itera sobre TODOS os ciclos do appData
            if (appData.cycles) {
                for (const cycleId in appData.cycles) {
                    const cycle = appData.cycles[cycleId];
                    if (cycle.studyHistory && cycle.studyHistory[today]) {
                        // Itera sobre cada entrada de disciplina no histórico do dia
                        Object.values(cycle.studyHistory[today]).forEach(disciplineRecords => {
                            // disciplineRecords é agora um ARRAY de objetos de estudo
                            if (Array.isArray(disciplineRecords)) {
                                totalSecondsStudiedTodayAllCycles += disciplineRecords.reduce((sum, record) => {
                                    return sum + (record.time || 0); // Soma a propriedade 'time' de cada registro
                                }, 0);
                            }
                        });
                    }
                }
            }

            // Atualiza o display das horas estudadas hoje
            document.getElementById('totalHours').textContent = formatTime(totalSecondsStudiedTodayAllCycles);
        }

        function updateDisciplinesList() {
            if (!activeCycle) return;
            const listEl = document.getElementById('disciplinesList');
            if (!listEl) return;
            listEl.innerHTML = activeCycle.disciplines.map((d, i) => {
                const isCompleted = d.targetSeconds > 0 && d.currentSeconds >= d.targetSeconds;
                const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                return `
                    <div class="discipline-item ${isCompleted ? 'completed' : ''}" id="discipline-${d.id}" style="border-left-color: ${disciplineColor};">
                        <div class="discipline-name-group">
                            <button class="edit-btn" title="Editar disciplina" onclick="openEditModal(${d.id})"><span class="material-icons-outlined">edit</span></button>
                            <span>${d.name}</span>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center; min-width: 100px;">
                            <span class="time-current">${formatTime(d.currentSeconds)}</span>
                            <span style="font-size: 12px; color: #666;">Meta: ${formatTime(d.targetSeconds)}</span>
                        </div>
                        <div class="timer-controls" style="display:flex; gap:8px; align-items:center;">
                            <button class="timer-btn ${d.isRunning ? 'stop' : ''}" onclick="toggleTimer(${d.id})">${d.isRunning ? 'Pausar' : 'Iniciar'}</button>
                            <button class="secondary" onclick="openAddTimeModal(${d.id})">Add Tempo</button>
                            <button class="remove-btn secondary" onclick="removeDiscipline(${d.id})">Remover</button>
                        </div>
                    </div>`;
            }).join('');
        }
        
        function updateTimerDisplay(discipline) {
            const itemEl = document.getElementById(`discipline-${discipline.id}`);
            if (!itemEl) return;
            itemEl.querySelector('.time-current').textContent = formatTime(discipline.currentSeconds);
            const isCompleted = discipline.targetSeconds > 0 && discipline.currentSeconds >= discipline.targetSeconds;
            if(isCompleted) { itemEl.classList.add('completed'); } 
            else { itemEl.classList.remove('completed'); }
            updateStats();
        }

        function createWheelChart() {
            const svg = document.getElementById('wheelChart');
            const tooltip = document.getElementById('tooltip');
            svg.innerHTML = ''; 
            if (!activeCycle || activeCycle.disciplines.length === 0) {
                svg.innerHTML = `<text x="200" y="200" text-anchor="middle" font-size="16">Adicione disciplinas para começar</text>`;
                return;
            }
            
            const totalStudied = activeCycle.disciplines.reduce((sum, d) => sum + d.currentSeconds, 0);
            const totalTarget = activeCycle.disciplines.reduce((sum, d) => sum + d.targetSeconds, 0);
            let startAngle = -90;
            const gapDegrees = 2;

            if (totalTarget === 0 && activeCycle.disciplines.length > 0) {
                const equalSliceAngle = 360 / activeCycle.disciplines.length;
                activeCycle.disciplines.forEach((d, i) => {
                    let sliceAngle = equalSliceAngle;
                    let endAngle = startAngle + sliceAngle;
                    if (sliceAngle > gapDegrees) {
                        const arcStart = startAngle + gapDegrees / 2;
                        const arcEnd = endAngle - gapDegrees / 2;
                        const path = createArc(200, 200, 150, 90, arcStart, arcEnd);
                        const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                        path.setAttribute("fill", disciplineColor);
                        path.addEventListener('mouseover', (e) => {
                            tooltip.innerHTML = `<strong>${d.name}</strong><br>Estudado: ${formatTime(d.currentSeconds)}<br>Meta: ${formatTime(d.targetSeconds)}`;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${e.clientX + 15}px`;
                            tooltip.style.top = `${e.clientY - 10}px`;
                        });
                        path.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
                        svg.appendChild(path);
                    }
                    startAngle = endAngle;
                });
            } else {
                activeCycle.disciplines.forEach((d, i) => {
                    let sliceAngle = totalTarget > 0 ? (d.targetSeconds / totalTarget) * 360 : 0;
                    if (sliceAngle === 0 && d.targetSeconds > 0) {
                        sliceAngle = 360 / activeCycle.disciplines.length;
                    }
                    let endAngle = startAngle + sliceAngle;

                    if (sliceAngle > gapDegrees) {
                        const arcStart = startAngle + gapDegrees / 2;
                        const arcEnd = endAngle - gapDegrees / 2;
                        const path = createArc(200, 200, 150, 90, arcStart, arcEnd);
                        const disciplineColor = getDisciplineColor(d.id, activeCycle.id);
                        path.setAttribute("fill", disciplineColor);
                        path.addEventListener('mouseover', (e) => {
                            tooltip.innerHTML = `<strong>${d.name}</strong><br>Estudado: ${formatTime(d.currentSeconds)}<br>Meta: ${formatTime(d.targetSeconds)}`;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${e.clientX + 15}px`;
                            tooltip.style.top = `${e.clientY - 10}px`;
                        });
                        path.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });
                        svg.appendChild(path);
                    }
                    startAngle = endAngle;
                });
            }

            const svgNS = "http://www.w3.org/2000/svg";
            function createText(x, y, content, size, weight, color, opacity = 1) {
                const textEl = document.createElementNS(svgNS, "text");
                textEl.setAttribute("x", x); textEl.setAttribute("y", y);
                textEl.setAttribute("text-anchor", "middle");
                textEl.setAttribute("font-size", size);
                if (weight) textEl.setAttribute("font-weight", weight);
                textEl.setAttribute("fill", color);
                textEl.setAttribute("opacity", opacity);
                textEl.textContent = content;
                return textEl;
            }
            
            svg.appendChild(createText("200", "185", "Estudei", "18", "500", "#6c757d"));
            svg.appendChild(createText("200", "215", formatTime(totalStudied), "28", "600", "#0d253f"));
            svg.appendChild(createText("200", "238", `de ${formatTime(totalTarget)}`, "16", "500", "#6c757d", 0.8));
        }

        function createArc(x, y, outerR, innerR, start, end) {
            if (end - start >= 360) end = start + 359.99;
            const startRad = (start * Math.PI) / 180, endRad = (end * Math.PI) / 180;
            const largeArc = (end - start) > 180 ? 1 : 0;
            const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
            const d = ["M",x + outerR * Math.cos(startRad),y + outerR * Math.sin(startRad),"A",outerR,outerR,0,largeArc,1,x + outerR * Math.cos(endRad),y + outerR * Math.sin(endRad),"L",x + innerR * Math.cos(endRad),y + innerR * Math.sin(endRad),"A",innerR,innerR,0,largeArc,0,x + innerR * Math.cos(startRad),y + innerR * Math.sin(startRad),"Z"].join(" ");
            p.setAttribute("d", d);
            return p;
        }
        
        function setCalendarView(mode) {
            calendarViewMode = mode;
            document.getElementById('view-toggle-month').classList.toggle('active', mode === 'month');
            document.getElementById('view-toggle-week').classList.toggle('active', mode === 'week');
            renderCalendar();
        }

        function navigateCalendar(direction) {
            if (calendarViewMode === 'month') {
                currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
            } else {
                currentCalendarDate.setDate(currentCalendarDate.getDate() + (direction * 7));
            }
            renderCalendar();
        }

        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            const titleEl = document.getElementById('calendarTitle');
            const summaryEl = document.getElementById('calendar-summary');
            grid.innerHTML = '';
            
            const allHistories = Object.values(appData.cycles).map(c => c.studyHistory).filter(Boolean);

            if (calendarViewMode === 'month') {
                const year = currentCalendarDate.getFullYear();
                const month = currentCalendarDate.getMonth();
                titleEl.textContent = `${currentCalendarDate.toLocaleString('pt-BR', { month: 'long', year: 'numeric' })}`;
                
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                let monthlyTotalSeconds = 0;

                for (let i = 0; i < firstDayOfMonth; i++) { grid.insertAdjacentHTML('beforeend', '<div></div>'); }

                for (let i = 1; i <= daysInMonth; i++) {
                    const date = new Date(year, month, i);
                    const isoDate = getLocalDateString(date);
                    let dailyTotal = 0;
                    allHistories.forEach(history => {
                        if (history[isoDate]) {
                            // Soma o tempo de todos os registros de estudo para este dia
                            Object.values(history[isoDate]).forEach(disciplineRecords => {
                                if (Array.isArray(disciplineRecords)) {
                                    dailyTotal += disciplineRecords.reduce((sum, record) => sum + (record.time || 0), 0);
                                }
                            });
                        }
                    });
                    monthlyTotalSeconds += dailyTotal;

                    let classes = 'calendar-day';
                    if (isoDate === getLocalDateString()) classes += ' today';
                    if (selectedDate === isoDate) classes += ' selected';
                    if (dailyTotal > 0) classes += ' has-studies';
                    grid.insertAdjacentHTML('beforeend', `<div class="${classes}" onclick="selectDate('${isoDate}')">${i}</div>`);
                }
                summaryEl.innerHTML = `Total no Mês: <strong>${formatTime(monthlyTotalSeconds)}</strong>`;

            } else { // 'week' view
                const weekStart = new Date(currentCalendarDate);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 6);

                titleEl.textContent = `${weekStart.toLocaleDateString('pt-BR')} - ${weekEnd.toLocaleDateString('pt-BR')}`;
                let weeklyTotalSeconds = 0;

                for (let i = 0; i < 7; i++) {
                    const date = new Date(weekStart);
                    date.setDate(date.getDate() + i);
                    const isoDate = getLocalDateString(date);
                    let dailyTotal = 0;
                     allHistories.forEach(history => {
                        if (history[isoDate]) {
                            // Soma o tempo de todos os registros de estudo para este dia
                            Object.values(history[isoDate]).forEach(disciplineRecords => {
                                if (Array.isArray(disciplineRecords)) {
                                    dailyTotal += disciplineRecords.reduce((sum, record) => sum + (record.time || 0), 0);
                                }
                            });
                        }
                    });
                    weeklyTotalSeconds += dailyTotal;

                    let classes = 'calendar-day';
                    if (isoDate === getLocalDateString()) classes += ' today';
                    if (selectedDate === isoDate) classes += ' selected';
                    if (dailyTotal > 0) classes += ' has-studies';
                    grid.insertAdjacentHTML('beforeend', `<div class="${classes}" onclick="selectDate('${isoDate}')">${date.getDate()}</div>`);
                }
                 summaryEl.innerHTML = `Total na Semana: <strong>${formatTime(weeklyTotalSeconds)}</strong>`;
            }
        }

       function selectDate(dateStr) {
            selectedDate = dateStr;
            renderCalendar(); 
            const infoEl = document.getElementById('selectedDateInfo');
            
            let dailyTotalSeconds = 0;
            let html = `<h4 style="color: #0d253f; font-weight: 600;">Estudos de ${new Date(dateStr + 'T12:00:00').toLocaleDateString('pt-BR')}</h4>`;
            let studiesFound = false;

            Object.values(appData.cycles).forEach(cycle => {
                if (cycle.studyHistory && cycle.studyHistory[dateStr]) {
                    Object.entries(cycle.studyHistory[dateStr]).forEach(([discId, records]) => {
                        if (Array.isArray(records)) {
                            const discipline = cycle.disciplines.find(d => d.id == discId);
                            if (discipline) {
                                records.forEach((record, index) => {
                                    html += `<div class="study-history-item"> 
                                                <span>
                                                    <strong>${discipline.name}</strong> (${cycle.id}): ${formatTime(record.time || 0)}
                                                    ${record.subject ? `<br><small>Assunto: ${record.subject}</small>` : ''}
                                                    ${record.tags && record.tags.length > 0 ? `<br><small>Tags: ${record.tags.join(', ')}</small>` : ''}
                                                    ${record.stopPoint ? `<br><small>Parada: ${record.stopPoint}</small>` : ''} 
                                                </span> 
                                                <button class="history-delete-btn" title="Apagar este registro" onclick="deleteHistoryEntry('${dateStr}', '${cycle.id}', '${discId}', ${index})">X</button> 
                                            </div>`;
                                    studiesFound = true;
                                    dailyTotalSeconds += (record.time || 0);
                                });
                            }
                        }
                    });
                }
            });

            const summaryHtml = `<div class="daily-total" style="display: flex; justify-content: space-between; align-items: center;">
                                    <span><strong>Total do Dia:</strong> ${formatTime(dailyTotalSeconds)}</span>
                                    <button class="secondary" onclick="openAddTimeToDayModal('${dateStr}')">Adicionar Tempo</button>
                                </div>`;

            if (!studiesFound) {
                html += `<p style="margin-top: 10px;">Nenhum estudo registrado para este dia.</p>`;
                infoEl.innerHTML = summaryHtml + html;
            } else {
                infoEl.innerHTML = summaryHtml + html;
            }
            infoEl.style.display = 'block';
        }
        
       function deleteHistoryEntry(dateStr, cycleId, disciplineId, recordIndex) { // Adicionado recordIndex
            showConfirmModal('Apagar Registro', 'Tem certeza? O tempo total da disciplina será recalculado.', () => {
                const cycle = appData.cycles[cycleId];
                if (!cycle || !cycle.studyHistory || !cycle.studyHistory[dateStr] || !cycle.studyHistory[dateStr][disciplineId]) return;
                
                const records = cycle.studyHistory[dateStr][disciplineId];
                if (!Array.isArray(records) || recordIndex < 0 || recordIndex >= records.length) return;

                const secondsToDelete = records[recordIndex].time || 0; // Pega o tempo do registro específico
                
                // Remove o registro do array
                records.splice(recordIndex, 1); 

                // Atualiza o currentSeconds da disciplina
                const discipline = cycle.disciplines.find(d => String(d.id) === disciplineId);
                if (discipline) {
                    discipline.currentSeconds = Math.max(0, discipline.currentSeconds - secondsToDelete);
                }

                // Se não houver mais registros para a disciplina no dia, remove a entrada da disciplina
                if (records.length === 0) {
                    delete cycle.studyHistory[dateStr][disciplineId];
                }
                
                // Se não houver mais disciplinas estudadas no dia, remove a entrada da data
                if (Object.keys(cycle.studyHistory[dateStr]).length === 0) {
                    delete cycle.studyHistory[dateStr];
                }

                saveData();
                selectDate(dateStr); 
                if (activeCycle && activeCycle.id === cycleId) updateDisplay();
            });
        }
        
        function initializeReportFilters() {
            const today = new Date();
            // Garante que estamos trabalhando com datas no início do dia
            reportStartDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            reportEndDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());

            if (typeof Litepicker !== 'undefined') {
                reportDatePicker = new Litepicker({
                    element: document.getElementById('report-date-input'),
                    singleMode: false, allowRepick: true, lang: "pt-BR",
                    lexicon: {"button_previous": "❮", "button_next": "❯", "button_apply": "Aplicar", "button_cancel": "Cancelar", "months": ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], "weekdays": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"]},
                    format: 'DD/MM/YYYY', startDate: reportStartDate, endDate: reportEndDate,
                    setup: (picker) => {
                        picker.on('selected', (date1, date2) => {
                            // Normaliza as datas para o início do dia
                            reportStartDate = new Date(date1.dateInstance.getFullYear(), date1.dateInstance.getMonth(), date1.dateInstance.getDate());
                            reportEndDate = new Date(date2.dateInstance.getFullYear(), date2.dateInstance.getMonth(), date2.dateInstance.getDate());
                            renderReportsView();
                        });
                    }
                });
            } else {
                console.error("Litepicker não está definido.");
            }
            populateCycleFilter();
            reportsInitialized = true;
        }

        function populateCycleFilter() {
            const selector = document.getElementById('report-cycle-filter');
            selector.innerHTML = '<option value="all">Todos os Projetos</option>';
            Object.keys(appData.cycles || {}).forEach(id => selector.innerHTML += `<option value="${id}">${id}</option>`);
        }

        function renderReportsView() {
            if (!reportsInitialized) return;
            const selectedCycle = document.getElementById('report-cycle-filter').value;
            const reportData = processReportData(reportStartDate, reportEndDate, selectedCycle);
            
            document.getElementById('report-total-hours').textContent = formatTime(reportData.totalSeconds);
            document.getElementById('report-daily-average').textContent = formatTime(reportData.dailyAverage);

            renderDurationBarChart(reportData.durationByDay);
            renderDistributionDonutChart(reportData.distributionByCycle);
            renderBreakdownTable(reportData.breakdown, reportData.totalSeconds);
        }

        function processReportData(startDate, endDate, selectedCycle) {
            let totalSeconds = 0;
            const durationByDay = {}; // Sum total for each day
            const distributionByCycle = {};
            const breakdown = {};
            let studyDaysCount = 0;

            const normalizedStartDate = getLocalDateString(startDate);
            const normalizedEndDate = getLocalDateString(endDate);

            // Initialize all days in the period with 0 to ensure continuity in charts
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                durationByDay[getLocalDateString(d)] = 0;
            }

            Object.values(appData.cycles).forEach(cycle => {
                if (selectedCycle !== 'all' && cycle.id !== selectedCycle) return;
                if (!cycle.studyHistory) return;

                Object.entries(cycle.studyHistory).forEach(([date, disciplineEntries]) => {
                    if (date >= normalizedStartDate && date <= normalizedEndDate) {
                        let dailySecondsFromRecords = 0; // Total for this day from all disciplines

                        Object.entries(disciplineEntries).forEach(([discId, records]) => {
                            if (Array.isArray(records)) {
                                records.forEach(record => {
                                    const seconds = record.time || 0;
                                    dailySecondsFromRecords += seconds; // Add to daily total
                                    
                                    // Update overall distribution by cycle
                                    distributionByCycle[cycle.id] = (distributionByCycle[cycle.id] || 0) + seconds;

                                    // Update breakdown structure
                                    if (!breakdown[cycle.id]) breakdown[cycle.id] = { totalSeconds: 0, disciplines: {} };
                                    breakdown[cycle.id].totalSeconds += seconds;
                                    breakdown[cycle.id].disciplines[discId] = (breakdown[cycle.id].disciplines[discId] || 0) + seconds;
                                });
                            }
                        });
                        
                        // Only count as a "study day" if there was actual study time recorded
                        if (dailySecondsFromRecords > 0 && !(getLocalDateString(new Date(date)) in durationByDay && durationByDay[getLocalDateString(new Date(date))] > 0)) {
                           studyDaysCount++; // Only increment if it's the first study on this day
                        }
                        durationByDay[date] = (durationByDay[date] || 0) + dailySecondsFromRecords;
                        totalSeconds += dailySecondsFromRecords;
                    }
                });
            });

            // Adjust studyDaysCount for ranges where days might have studies from multiple cycles
            // This is crucial for average calculation.
            let actualStudyDays = 0;
            for(const dateStr in durationByDay) {
                if (durationByDay[dateStr] > 0) {
                    actualStudyDays++;
                }
            }

            const dailyAverage = actualStudyDays > 0 ? totalSeconds / actualStudyDays : 0;
            return { totalSeconds, dailyAverage, durationByDay, distributionByCycle, breakdown };
        }

        function renderDurationBarChart(data) {
            const ctx = document.getElementById('durationBarChart');
            if (!ctx) return;
            const context = ctx.getContext('2d');
            const labels = Object.keys(data).map(dateStr => {
                const date = new Date(dateStr + 'T12:00:00');
                let day = date.toLocaleDateString('pt-BR', { weekday: 'short' });
                return day.charAt(0).toUpperCase() + day.slice(1).replace('.', '');
            });
            const values = Object.values(data);
            if (durationBarChart) durationBarChart.destroy();
            if (typeof Chart === 'undefined') { console.error("Chart.js não está definido."); return; }
            durationBarChart = new Chart(context, {
                type: 'bar',
                data: { labels: labels, datasets: [{ label: 'Duração', data: values, backgroundColor: REPORT_RESERVED_COLOR, borderRadius: 4, barThickness: 25 }] },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: { x: { type: 'category', grid: { display: false } }, y: { beginAtZero: true, ticks: { callback: (value) => formatTime(value).substring(0, 5) } } },
                    plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => `Duração: ${formatTime(ctx.raw)}` } } }
                }
            });
        }

        const doughnutText = {
            id: 'doughnutText',
            afterDraw(chart, args, options) {
                const { ctx } = chart; if (!options.text) return;
                const meta = chart.getDatasetMeta(0);
                if (!meta.data || meta.data.length === 0) return;
                const { total, label } = options.text;
                ctx.save();
                const x = meta.data[0].x; const y = meta.data[0].y;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = '500 1em Poppins'; ctx.fillStyle = '#6c757d';
                ctx.fillText(label, x, y - 12);
                ctx.font = '600 1.5em Poppins'; ctx.fillStyle = '#0d253f';
                ctx.fillText(total, x, y + 15);
                ctx.restore();
            }
        };

        function renderDistributionDonutChart(data) {
            const ctx = document.getElementById('distributionDonutChart');
            if (!ctx) return;
            const context = ctx.getContext('2d');
            const labels = Object.keys(data);
            const values = Object.values(data);
            
            // Usar as cores dos Projetos armazenadas
            const backgroundColors = labels.map(cycleId => {
                const cycle = appData.cycles[cycleId];
                return cycle ? cycle.color : '#CCCCCC'; // Fallback color
            });
            
            const totalSecondsInChart = values.reduce((sum, value) => sum + value, 0);
            const formattedTotalTime = formatTime(totalSecondsInChart);
            if (distributionDonutChart) distributionDonutChart.destroy();
            if (typeof Chart === 'undefined') { console.error("Chart.js não está definido."); return; }
            distributionDonutChart = new Chart(context, {
                type: 'doughnut',
                data: { labels: labels, datasets: [{ data: values, backgroundColor: backgroundColors, borderColor: '#fff', borderWidth: 2 }] },
                options: {
                    responsive: true, maintainAspectRatio: false, cutout: '70%',
                    plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `${c.label}: ${formatTime(c.raw)} (${(c.raw / c.chart.getDatasetMeta(0).total * 100).toFixed(1)}%)` } }, doughnutText: { text: { total: formattedTotalTime, label: 'Total' } } }
                },
                plugins: [doughnutText]
            });
        }

        function renderBreakdownTable(data, totalSeconds) {
            const tableBody = document.getElementById('breakdown-table-body');
            tableBody.innerHTML = '';
            if (Object.keys(data).length === 0) {
                tableBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #6c757d;">Nenhum dado para o período.</p>';
                return;
            }
            const sortedCycles = Object.entries(data).sort((a, b) => b[1].totalSeconds - a[1].totalSeconds);
            for (const [cycleId, cycleData] of sortedCycles) {
                const cycle = appData.cycles[cycleId];
                if (!cycle) continue;
                const percentage = totalSeconds > 0 ? ((cycleData.totalSeconds / totalSeconds) * 100).toFixed(1) : 0;
                
                // Usa a cor armazenada para o Projeto
                const cycleColor = cycle.color || '#CCCCCC'; // Fallback color
                
                const cycleRow = document.createElement('div');
                cycleRow.className = 'breakdown-row cycle-row';
                cycleRow.setAttribute('onclick', `toggleCycleDetails(this)`);
                cycleRow.innerHTML = `<div class="cycle-name-cell"><span class="material-icons-outlined toggle-arrow">chevron_right</span><span class="cycle-color-dot" style="background-color:${cycleColor};"></span><span>${cycleId}</span></div><span class="d-right">${formatTime(cycleData.totalSeconds)}</span><span class="d-right">${percentage}%</span>`;
                tableBody.appendChild(cycleRow);
                const disciplinesWrapper = document.createElement('div');
                disciplinesWrapper.className = 'discipline-rows-wrapper';
                const sortedDisciplines = Object.entries(cycleData.disciplines).sort((a, b) => b[1] - a[1]);
                for (const [discId, discSeconds] of sortedDisciplines) {
                    const discipline = cycle.disciplines.find(d => String(d.id) === discId);
                    if (discipline) {
                        const discPercentage = cycleData.totalSeconds > 0 ? ((discSeconds / cycleData.totalSeconds) * 100).toFixed(1) : 0;
                        disciplinesWrapper.innerHTML += `<div class="breakdown-row discipline-row"><span>${discipline.name}</span><span class="d-right">${formatTime(discSeconds)}</span><span class="d-right">${discPercentage}%</span></div>`;
                    }
                }
                tableBody.appendChild(disciplinesWrapper);
            }
        }

        function toggleCycleDetails(element) { element.classList.toggle('expanded'); }

        function formatTime(totalSeconds) {
            totalSeconds = Math.round(totalSeconds || 0);
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = Math.floor(totalSeconds % 60);
            return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }
        
        window.addEventListener('load', handleAuth);
    </script>
</body>
</html>
